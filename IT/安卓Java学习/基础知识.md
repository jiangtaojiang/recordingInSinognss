### “API”

 Application Programming Interface，其实就是操作系统留给应用程序的一个调用接口，应用程序通过调用操作系统的 API 而使操作系统去执行应用程序的命令（动作）。

API即“应用程序编程接口”，是一些预先定义的函数，目的是作为“介面”沟通两个不同的东西，提供应用程序与开发人员基于某软件或硬件得以访问一组例程的能力，而又无需访问源码，或理解内部工作机制的细节。



### SDK 

就是 Software Development Kit 的缩写，中文意思就是“软件开发工具包”。这是一个覆盖面相当广泛的名词，可以这么说：辅助开发某一类软件的相关文档、范例和工具的集合都可以叫做“SDK”。





### DLL

（又是一个缩写，感觉 IT 这个行业里三字头缩写特别多），即 Dynamic Link Library（动态链接库）。我们经常会看到一些 .dll 格式的文件，这些文件就是动态链接库文件，其实也是一种可执行文件格式。跟 .exe 文件不同的是，.dll 文件不能直接执行，他们通常由 .exe 在执行时装入，内含有一些资源以及可执行代码等。其实 Windows 的三大模块就是以 DLL 的形式提供的（Kernel32.dll，User32.dll，GDI32.dll），里面就含有了 API 函数的执行代码。为了使用 DLL 中的 API 函数，我们必须要有 API 函数的声明（.H）和其导入库（.LIB），函数的原型声明不难理解，那么导入库又是做什么用的呢？我们暂时先这样理解：导入库是为了在 DLL 中找到 API 的入口点而使用的。 

.dll用于运行阶段，如调用SetWindowText()函数等，需要在user32.dll中找到该函数。DLL可以简单认为是一种包含供别人调用的函数和资源的可执行文件。





### SDK作用

所以，为了使用 API 函数，我们就要有跟 API 所对应的 .H 和 .LIB 文件，而 SDK 正是提供了一整套开发 Windows 应用程序所需的相关文件、范例和工具的“工具包”。我们才真正的解释清楚了 SDK 的含义。 

由于 SDK 包含了使用 API 的必需资料，所以人们也常把仅使用 API 来编写 Windows 应用程序的开发方式叫做“SDK 编程”。而 API 和 SDK 是开发 Windows 应用程序所必需的东西，所以其它编程框架和类库都是建立在它们之上的，比如 VCL 和 MFC，虽然他们比起“SDK 编程”来有着更高的抽象度，但这丝毫不妨碍它们在需要的时候随时直接调用 API 函数。 





### 从接口interface来说

，在计算机领域是指两个不同事物之间交互的地方，大可以到两个完整的不同系统，小可以到两段程序。所以这个I就这么理解。在这个基础上，人和程序交互的地方，叫做UI，user interface,所有人输入的包括鼠标键盘触摸屏声音输入都算。那么程序和程序交互的就叫做API，所有非人对非人交互都通过API进行交互，所谓交互，其实就是传递数据，触发功能。





API是数据接口，在SDK环境下调用API数据





### .so文件

SO文件格式即ELF文件格式，它是Linux下可执行文件，共享库文件和目标文件的统一格式。



由于Android操作系统的底层基于Linux系统，所以SO文件可以运行在Android平台上。Android系统也同样开放了C/C++接口供开发者开发Native程序。

由于基于虚拟机的编程语言JAVA更容易被人反编译，因此越来越多的应用将其中的核心代码以C/C++为编程语言，并且以SO文件的形式供上层JAVA代码调用，以保证安全性。

而ELF头表记录了ELF文件的基本信息，包括魔数，目标文件类型（可执行文件，共享库文件或者目标文件），文件的目标体系结构，程序入口地址（共享库文件为此值为0），然后是section表大小和数目，程序头表的大小和数目，分别对应的是链接视图和装载视图。





### .lib文件

AndroidStudio中导入外部第三方jar包都存放在这个文件夹下面，这个目录下的包会被自动添加到构建路径里去

C中.lib用于链接阶段，在链接各部分目标文件（通常为.obj）到可执行文件（通常为.exe）过程中，需要在.lib文件中查找动态调用函数（一般为DLL中的函数）的地址信息，此时需要在.lib中查找，如查找SetWindowText()函数的地址偏移就需要查找user32.lib文件。（.lib也可用于静态链接的内嵌代码）

​             





### 位运算

| &    | 与   | 两个位都为1时，结果才为1                                     |
| ---- | ---- | :----------------------------------------------------------- |
| \|   | 或   | 两个位都为0时，结果才为0                                     |
| ^    | 异或 | 两个位相同都为0，相异为1                                     |
| ~    | 取反 | 0变1，1变0                                                   |
| <<   | 左移 | 各位全部左移若干位，高位丢弃，低位补0                        |
| >>   | 右移 | 各二进位全部右移若干位，对无符号数，高位补0，有符号数，各编译器处理方法不一样，有的补符号位（算术右移），有的补0（逻辑右移） |







### 正则表达式(regular expression)    ---Regex

描述了一种字符串匹配的模式（pattern），可以用来检查一个串是否含有某种子串、将匹配的子串替换或者从某个串中取出符合某个条件的子串等。

例如：

- **runoo+b**，可以匹配 runoob、runooob、runoooooob 等，+ 号代表前面的字符必须至少出现一次（1次或多次）。
- **runoo\*b**，可以匹配 runob、runoob、runoooooob 等，* 号代表字符可以不出现，也可以出现一次或者多次（0次、或1次、或多次）。
- **colou?r** 可以匹配 color 或者 colour，? 问号代表前面的字符最多只可以出现一次（0次、或1次）。

java中的正则表达式主要包括三种

- Pattern 类：

  pattern 对象是一个正则表达式的编译表示。Pattern 类没有公共构造方法。要创建一个 Pattern 对象，你必须首先调用其公共静态编译方法，它返回一个 Pattern 对象。该方法接受一个正则表达式作为它的第一个参数。

- Matcher 类：

  Matcher 对象是对输入字符串进行解释和匹配操作的引擎。与Pattern 类一样，Matcher 也没有公共构造方法。你需要调用 Pattern 对象的 matcher 方法来获得一个 Matcher 对象。

- PatternSyntaxException：

  PatternSyntaxException 是一个非强制异常类，它表示一个正则表达式模式中的语法错误。







### ArrayList数组列表类似于数据结构上的链表---数组





### 链表

头指针就是链表的名字，仅仅是个指针而已。头结点是为了操作的统一与方便而设立的，放在第一个有效元素结点（首元结点）之前，其数据域一般无意义（当然有些情况下也可存放链表的长度、用做监视哨等等）。一般情况下见到的链表的指针多为头指针，但最近在一个程序员编程网站leetcode中发现，题目中所给的链表一般是首元结点作为第一个元素，而不是头指针。

typedef struct LinkList                                                                                                                                     

{

         int Element;
    
         LinkList * next;

}LinkList;

哈希表--映射函数







### 泛型

T、E、K、V等形式的参数常用于表示泛型形参

\* E - Element (在集合中使用，因为集合中存放的是元素)
\* K - Key（键）
\* N - Number（数值类型）
\* T - Type（Java 类）
\* V - Value（值）
\* S,U,V etc. - 2nd, 3rd, 4th types 







### 魔法值

未经定义的值

使得阅读性降低

给数字或者变量以可阅读性的实际名字

原则上数值就是魔法值，他不代表任何意义











### 适配器baseAdapter

```
arrayAdapter = new ArrayAdapter<>(MainActivity.this,android.R.layout.simple_list_item_1, bluetoothList);
```

**android.R.layout.simple_expandable_list_item_1** 其实这些是系统给我们提供好的一些ListView模板







### java 中继承时子类——重写父类方法

```
1. 普通类继承，并非一定要重写父类方法。
2. 抽象类继承，如果子类也是一个抽象类，并不要求一定重写父类方法。如果子类不是抽象类，则要求子类一定要实现父类中的抽象方法。
3. 接口类继承。如果是一个子接口，可以扩展父接口的方法；如果是一个子抽象类，可以部分或全部实现父接口的方法；如果子类不是抽象类，则要求子类一定要实现父接口中定义的所有方法。
```

1. 父类中的方法在子类中必须可见，即子类继承了父类中的该方法（可以显式的使用super关键字来访问父类中的被重写的方法），如果父类中的方法为private类型的，那么子类则无法继承，也无法覆盖。
2. 子类和父类的方法必须是实例方法，如果父类是static方法而子类是实例方法，或者相反都会报错。 如果父类和子类都是static方法，那么子类隐藏父类的方法，而不是重写父类方法。
3. 子类和父类的方法必须要具有相同的函数名称、参数列表，并且子类的返回值与父类相同或者是父类返回类型的子类型（jdk1.5之后）。 如果方法名称相同而参数列表不同（返回类型可以相同也可以不同），那么只是方法的重载，而非重写。 如果方法名称和参数列表相同，返回值类型不同，子类返回值类型也不是父类返回值类型的子类，编译器就会报错。 
4. 子类方法的访问权限不能小于父类方法的访问权限（可以具有相同的访问权限或者子类的访问权限大于父类）。 访问权限由高到低：public、protected、包访问权限、private。如果子类方法的访问权限低于父类，则编译器会给出错误信息
5. 子类方法不能比父类方法抛出更多的编译时异常（不是运行时异常），即子类方法抛出的编译时异常或者和父类相同或者是父类异常的子类。

https://blog.csdn.net/Mus_Li/article/details/77899349







### var

json转换为JavaScript对象：JavaScript使用内建的eval（）函数吧json数据生成原生的JavaScript对象



variable/variation 变量的简称var

在计算机语言中var作为定义变量的关键字

pascal语言--- var a:interger

JS中使用var关键字定义变量、函数、对象

由于js中的变量是弱类型的，因此js中的所有变量包括number（数字型）、string（字符串类型）、boolean（布尔类型，true和false）等均通过var关键字来定义。







Json数据





### jar包

开发出的应用程序，自写出很多类，若需要把这个应用程序提供给别人，会把这些类文件打包成jar包。只要别人在系统的CLASSPATH环境变量中添加这个JAR文件，则Java虚拟机就可以自动在内存中解压这个JAR包，把这个JAR文件当成一个路径，在这个路径中查找所需要的类或包层次对应的路径结构。

### lib包与jar包

1 : library是类库,就是一堆.jar文件的集合.一般情况下都是若干个.class文件能实现一组功能,这时候便可以把这些.class文件打包成.jar文件.比如说当需要使用集合类的时候,咱们需要import java.uitl.*; 对应的就是一个jar包(.jar文件)它里面就是一堆.class文件。
2：library是一个库的集合，library可以包含多个jar文件，jar包是封装好的javaclass类。

lib就是一堆jar包的集合、那么jar包里面肯定还有子包，子包里就是基本的单位类了

 

通常在lib包文件下添加外部引入的jar包

