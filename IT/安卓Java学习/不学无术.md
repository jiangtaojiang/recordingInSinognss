不学无术

android中的布局
Android中有六大布局
LinearLayout(线性布局)  RelativeLayout(相对布局)  TableLayout(表格布局)  FrameLayout(帧布局)  AbsoluteLayout(绝对布局)  GridLayout(网格布局) 

JAVA中：类名的标识符一般用大驼峰式书写格式，方法和变量的标识符则多用小驼峰式书写格式。
数组定义如下： String[] args ; 反例:使用 String args[] 的方式来定义。

javabean  


多线程：Callable+Future/FutureTask却可以获取多线程运行的结果，可以在等待时间太长没获取到需要的数据的情况下取消该线程的任务


在f()函数中对可能出现的异常的代码进行try catch处理后,  程序会执行catch里的代码. 而且不会中断整个程序, 继续执行try catch后面的代码.



我做了一个组合式控件，我要对其中一个TextView设置一个DrawableLeft属性，我在attrs配置了
<attr name="item_icon" format="reference|color"/>
然后我在那个控件属性里设置了:
item_icon="@mipmap/ic_launcher"
接着我在Java代码里写了:
TypedArray localTypedArray = context.obtainStyledAttributes(attrs, R.styleable.setting_info);


WRAP_CONTENT、MATCH_PARENT/FILL_PARENT属性的原理说明
① fill_parent
设置一个视图的布局为fill_parent将强制性地使视图扩展至父元素大小。
② match_parent
Android 中match_parent和fill_parent意思一样，但match_parent更贴切，于是从2.2开始两个词都可以
用，但2.3版本后建议使用match_parent。
③ wrap_content
自适应大小，强制性地使视图扩展以便显示其全部内容。以TextView和ImageView控件为例，设置为
wrap_content将完整显示其内部的文本和图像。布局元素将根据内容更改大小。


调用：
动态: ibtnPen.setBacklgroundResource(R.drawable.penbg);

静态: android:background = "@drawable/penbg"


四大组件：
activity（界面）、service（服务）、content provider（数据交换）、broadcast receiver（广播）。


Adapter是用来帮助填充数据的中间桥梁，简单点说就是：将各种数据以合适的形式显示到view上,提供 给用户看！



在res\valuse下创建一个数组资源的xml文件：arrays.xml：

<?xml version="1.0" encoding="utf-8"?>  
<resources>  
    <string-array name="myarray">  
    <item>语文</item>  
    <item>数学</item>  
    <item>英语</item>  
    </string-array>      
</resources>
入口：统一进UI设置   android:entries="@array/myarray"/>


textview是view的子类，位于android.widget包中

viewgroup 继承view类


strings.xml主要定义字符串常量


src文件


UI界面不仅可以通过XML控制，也可以通过JAVA控制

new module

 

Toast.makeText(MainActivity.this, "提示的内容", Toast.LENGTH_LONG).show();
第一个是上下文对象！对二个是显示的内容！第三个是显示的时间，只有LONG和SHORT两种 会生效，即时你定义了其他的值，最后调用的还是这两个！

import android.os.Bundle; 意义：

不知道如何写类、调用方法、界面显示


import android.app.Activity？什么意思，是否是调取本项目中新定义的JAVA类


 btnshow.setOnClickListener(new OnClickListener()


 btnshow = (Button) findViewById(R.id.btnshow);    
  btnshow.setOnClickListener(new BtnClickListener());    


两个.JAVA文件之间关系：调用？------ btnshow.setOnClickListener(new MyClick(txtshow));    



 btnshow = (Button) findViewById(R.id.btnshow);    
        //直接写个this    
        btnshow.setOnClickListener(this);    


activity：
栈存储


自定义类名并且继承
class MyActivity extends activity


Android中的四大组件，只要你定义了，无论你用没用，都要在AndroidManifest.xml对 这个组件进行声明，不然运行时程序会直接退出，报ClassNotFindException


相信用as的朋友在重写Act的onCreate()方法时会发现，这玩意有两个参数，可是正常的才只有一个参数；要用它，先要在配置文件中为Activity设置一个属性：

android:persistableMode="persistAcrossReboots"



AndroidManifest.xml完成Service注册

<!-- 配置Service组件,同时配置一个action -->  
<service android:name=".TestService1">  
            <intent-filter>  
                <action android:name="com.jay.example.service.TEST_SERVICE1"/>  
            </intent-filter>  
</service>  


broadcast 信息传输的一种方式 sendBroadcast



往AndroidManifest.xml加入读取收件箱的权限：

<uses-permission android:name="android.permission.READ_SMS"/>



intent作为数据的转移者


bundle传递数据，它封装了简单的数据类型
实例化bundle bundle=new bundle();
bundle.putstring();
把bundle放在intent中 intent.putExtra("Message",bundle);

intent的extra属性是一个bundle对象，通过键值进行数据储存
bundle:intent.putExtras().getExtra();


定义全局数据跳过多个activity
application全局对象



区别与联系：
 this表示一个对象的引用,它指向正在执行方法的对象.

super是指向父类的引用，如果构造方法没有显示地调用父类的构造方法，
那么编译器会自动为它加上一个默认的super()方法调用。
如果父类由没有默认的无参构造方法，编译器就会报错，
super()语句必须是构造方法的第一个子句。
super（参数）：调用基类中的某一个构造函数（应该为构造函数中的第一条语句） 

　　2)this（参数）：调用本类中另一种形成的构造函数（应该为构造函数中的第一条语句）
　　3)super:　它引用当前对象的直接父类中的成员（用来访问直接父类中被隐藏的父类中成员数据或函数，基类与派生类中有相同成员定义时如：super.变量名    super.成员函数据名（实参）

　　4)this：它代表当前对象名（在程序中易产生二义性之处，应使用this来指明当前对象；如果函数的形参与类中的成员数据同名，这时需用this来指明成员变量名）

　　5）调用super()必须写在子类构造方法的第一行，否则编译不通过。每个子类构造方法的第一条语句，都是隐含地调用super()，如果父类没有这种形式的构造函数，那么在编译的时候就会报错。

　　6）super()和this()类似,区别是，super()从子类中调用父类的构造方法，this()在同一类内调用其它方法。

　　7）super()和this()均需放在构造方法内第一行。

　　8）尽管可以用this调用一个构造器，但却不能调用两个。

　　9）this和super不能同时出现在一个构造函数里面，因为this必然会调用其它的构造函数，其它的构造函数必然也会有super语句的存在，所以在同一个构造函数里面有相同的语句，
     就失去了语句的意义，编译器也不会通过。

　　10）this()和super()都指的是对象，所以，均不可以在static环境中使用。包括：static变量,static方法，static语句块。

　　11）从本质上讲，this是一个指向本对象的指针, 然而super是一个Java关键字。






6.修改Android 平台 PlayerSetting 的Bundle Identifier,要与Android工程的PackageName一致。
bundle Identifier    com.lxfeng.test



注册
<service android:name=".TestService2" android:exported="false">

        <intent-filter>
      
            <action android:name="com.jay.example.service.TEST_SERVICE2"/>
      
        </intent-filter>

</service> 
都在application下面注册


在 Android 中，主要通过 findViewById() 方法获取操作对象


xmlns:android="http://schemas.android.com/apk/res/android的作用是
<span style="font-size: 13px;">是xml的命名空间，可以alt+/作为提示，提示你输入什么，不该输入什么，
什么是对的，什么是错的，也可以理解为语法文件。或者语法判断器什么的
</span>
<span style="font-size: 13px;">这个主要作用是在运行的时候那些控件的属性都是通过它来识别的，如果上面你写错了，不会有任何问题，
但是在运行的时候就会有问题，提示你没有指定宽度等什么



单核CPU上运行的多线程程序, 同一时间只能一个线程在跑, 系统帮你切换线程而已
如果要做人机交互，最好还是要用多线程，避免用户没法对计算机进行操作。



一、Log.v 的调试颜色为黑色的，任何消息都会输出，这里的v代表verbose啰嗦的意思，平时使用就是Log.v(“”,”“);


二、Log.d的输出颜色是蓝色的，仅输出debug调试的意思，但他会输出上层的信息，过滤起来可以通过DDMS的Logcat标签来选择


三、Log.i的输出为绿色，一般提示性的消息information，它不会输出Log.v和Log.d的信息，但会显示i、w和e的信息


四、Log.w的意思为橙色，可以看作为warning警告，一般需要我们注意优化Android代码，同时选择它后还会输出Log.e的信息。


五、Log.e为红色，可以想到error错误，这里仅显示红色的错误信息，这些错误就需要我们认真的分析，查看栈的信息了。




四大组件使用时必须加入配置代码

方法都在一个activity中写还是开辟多个活动


bundle我们经常使用Bundle在Activity之间传递数据，传递的数据可以是boolean、byte、int、long、float、
double、string等基本类型或它们对应的数组，
也可以是对象或对象数组。当Bundle传递的是对象或对象数组时，必须实现Serializable 或Parcelable接口。




Action,Data,或Category


 <item android:drawable="@mipmap/tab_channel_pressed" android:state_selected="true" />


Socket是网络运行程序间双向通信链路的终结点， 是TCP和UDP的基础



mainactivity中只允许出现一个public创建类

MVC模式



LinearLayout ly = new LinearLayout(this);
ly.setOrientation(LinearLayout.VERTICAL)


Java控制界面事例：
	RelativeLayout rly = new RelativeLayout(this);  
        Button btnOne = new Button(this);  
        btnOne.setText("按钮1");  
        Button btnTwo = new Button(this);  
        btnTwo.setText("按钮2");  
        // 为按钮1设置一个id值  
        btnOne.setId(123);  
        // 设置按钮1的位置,在父容器中居中  
        RelativeLayout.LayoutParams rlp1 = new RelativeLayout.LayoutParams(  
                LayoutParams.WRAP_CONTENT, LayoutParams.WRAP_CONTENT);  
        rlp1.addRule(RelativeLayout.CENTER_IN_PARENT);  
        // 设置按钮2的位置,在按钮1的下方,并且对齐父容器右面  
        RelativeLayout.LayoutParams rlp2 = new RelativeLayout.LayoutParams(  
                LayoutParams.WRAP_CONTENT, LayoutParams.WRAP_CONTENT);  
        rlp2.addRule(RelativeLayout.BELOW, 123);  
        rlp2.addRule(RelativeLayout.ALIGN_PARENT_RIGHT);  
        // 将组件添加到外部容器中  
        rly.addView(btnTwo, rlp2);  
        rly.addView(btnOne, rlp1);  
        // 设置当前视图加载的View即rly  
        setContentView(rly);  



java代码中绑定xml文件中的view控件：
private void bindViews() {
        tv_value1 = (TextView) findViewById(R.id.tv_value1);
        tv_value2 = (TextView) findViewById(R.id.tv_value2);
        tv_value3 = (TextView) findViewById(R.id.tv_value3);
}


Java中final修饰的类不可被继承


model view control模式




JavaBean是一种可重用的Java组件，它可以被Applet、Servlet、SP等Java应用程序调用．
也可以可视化地被Java开发工具使用。它包含属性(Properties)、方法(Methods)、事件(Events)等特性。



UUID 是 通用唯一识别码（Universally Unique Identifier）的缩写


widget小物件


i指的是info，信息的意思，和log.w()代表warn,log.e()代表error,log.v()代表verbose,
log.d()代表debug一样，都是用来输出日志，只是标记不一样


java 中args一般存在main主类方法内，String args[ ]或者String[ ] args表示给主方法传一个字符串数组. 
而args是一个字符串数组的变量名，不是关键字，是arguments的缩写，只是一个默认名，一般都习惯性照写.



安卓加开发中，函数基本都可以写在同一个activity。Java文件中，类名可以单独创建



AppCompatActivity类里面的一个方法。那么这个方法的作用是什么呢？onCreate方法主要是初次启动（指使用这个类）首先加载的方法。
看清楚一个关键词：首先。也就是这个方法具有以下特点：就运行一次，而且是最先运行。

做个对比，其实就是写java练习代码里面的main方法，首次加载进入的入口就在这里。
其实可以想到，开发这个SDK的人，肯定就是封装了main方法，被他封装了成在android SDK上叫做onCreate。

@Override中文意思就是重写，在java里面我们继承来的，我们要使用就要重写，也就是重写嘛。
覆盖掉原来的oncreate方法，我们帮他重写一个oncreate，按照我的想法去执行这个方法。



findviewByid


ass




1、对于一个没有被载入或者想要动态载入的界面，都需要使用LayoutInflater.inflate()来载入；
2、对于一个已经载入的界面，就可以使用Activiyt.findViewById()方法来获得其中的界面元素。
获取：LayoutInflater inflater = LayoutInflater.from(context);



可以随便放置
Toast.makeText(getApplicationContext(), "按钮被点击了", Toast.LENGTH_SHORT).show();   






private Set<BluetoothDevice> pairedDevices;
声明的一个成员变量pairedDevices,它是一个set集合对象，可以放的是BluetoothDevice
由于集合是一种容器，相当于是一个瓶子，那么java提供了一种功能，就是在尖括号中声明这种容器是什么类型的容器，
比如说是酒瓶，只能装酒。这是集合对象泛型的概念。



广播：：：：：：：
// 广播接收器
/*    private final BroadcastReceiver mReceiver = new BroadcastReceiver() {

        @Override
        public void onReceive(Context context, Intent intent) {
            // 收到的广播类型
            String action = intent.getAction();
            // 发现设备的广播
            if (BluetoothDevice.ACTION_FOUND.equals(action)) {
                // 从intent中获取设备
                BluetoothDevice device = intent
                        .getParcelableExtra(BluetoothDevice.EXTRA_DEVICE);
                // 判断是否配对过
                if (device.getBondState() != BluetoothDevice.BOND_BONDED) {
                    // 添加到列表
                    DeviceView.append(device.getName() + ":"
                            + device.getAddress() + "\n");
                }
                // 搜索完成
            } else if (BluetoothAdapter.ACTION_DISCOVERY_FINISHED
                    .equals(action)) {
                // 关闭进度条
                setProgressBarIndeterminateVisibility(true);
                setTitle("搜索完成！");
            }
        }
    };*/




广播发送intent拦截intent
public void broadcastIntent(View view)------>
 public void onReceive(Context context, Intent intent) ---->


ArrayAdapter的构造需要三个参数，依次为this,布局文件（注意这里的布局文件描述的是列表的每一行的布局，
android.R.layout.simple_list_item_1是系统定义好的布局文件只显示一行文字，数据源(一个List集合)。
同时用setAdapter（）完成适配的最后工作



 listView.setAdapter(adapter);.
setContentView(listView);



foreach的语句格式： 
for(元素类型t 元素变量x : 遍历对象obj){ 
引用了x的java语句; 
} 



        //如果广播的事件并不是我们定义的广播接收器需要的事件类型，一般是会过滤掉不被接收。
        //只有当广播事件和我们写的接收器定义的接收的事件类型一致的时候才会触发广播接收器。
        // 异步搜索蓝牙设备——广播接收
        // 找到设备的广播
    /*  IntentFilter filter = new IntentFilter(BluetoothDevice.ACTION_FOUND);
        // 注册广播
        registerReceiver(mReceiver, filter);
        // 搜索完成的广播
        filter = new IntentFilter(BluetoothAdapter.ACTION_DISCOVERY_FINISHED);
        // 注册广播
        registerReceiver(mReceiver, filter);
    */


notifyDataSetChanged()可以在修改适配器绑定的数组后，不用重新刷新Activity，通知Activity更新ListView





if(BluetoothDevice.ACTION_FOUND.equals(action)){
                BluetoothDevice device = intent.getParcelableExtra(BluetoothDevice.EXTRA_DEVICE);
                deviceName.add("设备名："+device.getName()+"\n" +"设备地址："+device.getAddress() + "\n");
//将搜索到的蓝牙名称和地址添加到列表。


接口回调是指：可以把使用某一接口的类创建的对象的引用赋给该接口声明的接口变量，
那么该接口变量就可以调用被类实现的接口的方法。
实际上，当接口变量调用被类实现的接口中的方法时，就是通知相应的对象调用接口的方法，
这一过程称为对象功能的接口回调




buider.gradle(app中的dependencies加入):

implementation 'com.jakewharton:butterknife:8.8.1'

annotationProcessor 'com.jakewharton:butterknife-compiler:8.8.1'

即可使用：

@BindView(R.id.text1)
TextView textView;
代替：

findviewbyid方法。





startActivities期望提供一组Intent（Intent []）。你试图在那里传递一个Intent。请startActivity(Intent)改用。
正解：startActivities(new Intent[]{new Intent(MainActivity.this,testactivity.class)});
错误：Intent intent=new Intent(MainActivity.this,testactivity.class);
	startactivity(intent);







fragment数据传输
Step 1:定义一个回调接口:(Fragment中)

/*接口*/  
public interface CallBack{  
    /*定义一个获取信息的方法*/  
    public void getResult(String result);  
}  
Step 2：接口回调（Fragment中）

/*接口回调*/  
public void getData(CallBack callBack){  
    /*获取文本框的信息,当然你也可以传其他类型的参数,看需求咯*/  
    String msg = editText.getText().toString();  
    callBack.getResult(msg);  
}  
Step 3:使用接口回调方法读数据(Activity中)

/* 使用接口回调的方法获取数据 */  
leftFragment.getData(new CallBack() {  
 @Override  
       public void getResult(String result) {              /*打印信息*/  
            Toast.makeText(MainActivity.this, "-->>" + result, 1).show();  
            }
        }); 





JavaBean 是一种JAVA语言写成的可重用组件。为写成JavaBean，类必须是具体的和公共的，并且具有无参数的构造器。
JavaBean 通过提供符合一致性设计模式的公共方法将内部域暴露成员属性，set和get方法获取。
属性名称符合这种模式，其他Java 类可以通过自省机制(反射机制)发现和操作这些JavaBean 的属性。



线程池：
线程池（英语：thread pool）：一种线程使用模式。线程过多会带来调度开销，进而影响缓存局部性和整体性能。
而线程池维护着多个线程，等待着监督管理者分配可并发执行的任务。这避免了在处理短时间任务时创建与销毁线程的代价。
线程池不仅能够保证内核的充分利用，还能防止过分调度。
可用线程数量应该取决于可用的并发处理器、处理器内核、内存、网络sockets等的数量。
 例如，线程数一般取cpu数量+2比较合适，线程数过多会导致额外的线程切换开销



Gradle是一个基于JVM的构建工具，是一款通用灵活的构建工具，



log输出
logd直接加tab按键
logt加入tab按键直接以当前类名值作为TAG常量


快捷重写方法control+O


知道当前是哪一个活动，新建一个Java类继承appcompatactivity,
打印当前实例的类型，
让所有页面继承这个类




button的两种启动方式
匿名类：直接在oncreate中写事件监听器
继承接口：在oncreate外写函数




定义一个实体类，
指定为Listview适配器的适配类型
为LV子项指定一个自定义的 布局
创建自定义的布局



安卓中，布局文件也是可以通过创建类实现，
连接通过Android：name=“类名”实现




广播接收器
创建一个新类，继承自Broadcastreceiver
重写onreceiver
z这样广播到来时，onreceive（）方法会被执行


设置intentfilter并实例化
创建监听器实例
注册广播
注销广播


发送标准广播：
1、定义广播接收器
2、自定义广播
3、




安卓多线程编辑

只需要定义一个类继承自线程
重写run方法
class mythread extend Thread{
@override
public viod run(){

}

}


如何开启线程
new出mythread的实例，调用它的start方法
new mythread().start();


class mythread implements runnable{
@override
public viod run(){

}

}

启动
myThread mm=new mythread();
new thread(mythread).start();




安卓不允许在子线程中更新UI


C#多线程编辑


大型项目定制自己的日至工具---第一行代码



按钮的点击事件
tart.setOnClickListener(new OnClickListener() {              
            @Override  
            public void onClick(View v) {  
                startService(intent);                 
            }  
        });  






Java   C#匿名函数：
读作goes to:->	=>

delegate int del(int i);
del myDelegate=x=>{return x*x;};
int j = myDelegate(5); //j=25


=> 运算符具有与赋值运算符 (=) 相同的优先级，并且是右结合运算符。


java:
使用lambda前：
Runnable runnable1=new Runnable(){
@Override
public void run(){
    System.out.println("Running without Lambda");
}
};
使用lambda后：
Runnable runnable2=()->System.out.println("Running from Lambda");



C# 泛型
特性：允许程序员在强类型程序设计语言中编写代码时定义一些可变部分，那些部分在使用前必须作出指明。
本质是：参数化类型

写一个泛型方法，该方法在调用时可以接收不同类型的参数。根据传递给泛型方法的参数类型，编译器适当地处理每一个方法调用。
规则：
	1·所有泛型方法声明都有一个类型参数声明部分（由尖括号分隔），该类型参数声明部分在方法返回类型之前
（在下面例子中的<E>）。
	2·每一个类型参数声明部分包含一个或多个类型参数，参数间用逗号隔开。一个泛型参数，
也被称为一个类型变量，是用于指定一个泛型类型名称的标识符。
	3·类型参数能被用来声明返回值类型，并且能作为泛型方法得到的实际参数类型的占位符。
	4·泛型方法体的声明和其他方法一样。注意类型参数只能代表引用型类型，不能是原始类型
（像int,double,char的等）。


java 中...表示//表示的传入的参数可以随意，你传多少个参数都被放到一个数组里面。
比如
public static void dealArray(int...intArray) {
for(int i: intArray)
{
System.out.print(i +" ");
}
System.out.println();
}



接口和类
接口是实现的方法
类包含属性和方法
接口不能实例化
接口之间的继承使用extend关键字
类继承接口使用implement关键字
类不允许多继承，接口允许多继承，使用extend关键字后跟上继承的接口用逗号隔开



java包，
package net.java.util
public class something
一个包（package）可以定义为一组相互联系的类型（类、接口、枚举和注释），为这些类型提供访问保护和命名空间管理的功能。

以下是一些 Java 中的包：
java.lang-打包基础的类
java.io-包含输入输出功能的函数




通配符“*”
import payroll.*







ButterKnife 算是一款知名老牌 Android 开发框架了，通过注解绑定视图，避免了 findViewById() 的操作

ButterKnife是一个专注于Android系统的View注入框架,当一个布局十分复杂时,
需要引入执行大量的findViewById代码
来找到View的对象,有了ButterKnife可以很轻松的省去这些步骤。

强大的View绑定事件和资源文件的绑定




API29资源没有问题：更改grandle Scripts 目录下的build.gradle
更改  compileSdkVersion 28
    buildToolsVersion "28.0.1"


	targetSdkVersion 28
原因是没有API29资源



source for Android29



start运行的是run的代码。在线程中编写实现代码



线程，继承他的线程，跑它里面的代码；
定义一个成员变量
获取他的方法，
传递给它，就能用了



listview按键响应事件的注册

itemposition只是响应位置，真正拿出东西还是得adapter；




官网代码overview
可以转成中文


position是位置信息
获取内容还是得要adapter


1、效果上没区别，写法上的区别而已。
2、没有可比性，Thread实现了Runnable接口并进行了扩展，
我们通常拿来进行比较只是写法上的比较，而Thread和Runnable的实质是实现的关系，不是同类东西。



广播事件
广播过滤器】
注册广播



创建
启动线程，即可运行run内容


listadapter的实例过程会指定形式
arrayadapter也会指定形式

秒退查看logcat可能是初始activity设置为问题，也可能是加载试图

listview点击函数需要使得mainactivity继承自onItemClickListener


定义接口

响应事件

线程

alt + shift +上下：可以把整行上下平移


如何知道一个线程的开始和结束：使用接口，实现方法，调用


创建事件监听器接口

线程中可以自定义多个参数


匿名内部类就是没有名字的内部类

直接将抽象类Person中的方法在大括号中实现了：
abstract class Person {
    public abstract void eat();
}
public class Demo {
    public static void main(String[] args) {
        Person p = new Person() {
            public void eat() {
                System.out.println("eat something");
            }
        };
        p.eat();
    }
}








抽象类不能生成对象


回调：
接收到广播信号，即可会执行这个代码



抛出异常
1自动
2throw	throw new NumberFormatException();
3.throws
对比
1、throws出现在方法函数头，而throw出现在函数体。

2、throws表示出现异常的一种可能性，并不一定会发生这些异常，throw则是抛出了异常，
执行throw则一定抛出了某种异常对象。
3、两者都是消极处理异常的方式（这里的消极并不是说这种方式不好）
只是抛出或者可能抛出异常，但不会由函数去处理异常，真正的处理异常由函数的上层调用处理。
 	

处理方法
1、在写程序时，对可能会出现异常的部分通常要用try{…}catch{…}去捕捉它并对它进行处理；

2、用try{…}catch{…}捕捉了异常之后一定要对在catch{…}中对其进行处理，
	那怕是最简单的一句输出语句，或栈输入e.printStackTrace();

3、如果是捕捉IO输入输出流中的异常，一定要在try{…}catch{…}后加finally{…}把输入输出流关闭；

4、如果在函数体内用throw抛出了某种异常，最好要在函数名中加throws抛异常声明，
	然后交给调用它的上层函数进行处理。




快捷键control+O快速重写方法


主线程创建Handler不需要创建looper
子线程创建需要通过looper.prepare创建
Looper.prepare();  





java支持的标准注释有3种：
1、// 注释一行
2、/* ...... */ 注释若干行
3、文档注释：/** ...... */ 注释若干行，并写入 javadoc 文档
通常这种注释的多行写法如下：
/**
* .........
* .........
*/



修改包名  找到位置rename
	左下方do refactor



参数类型有要求的话，可以在使用的方法前面进行参数设置




arrayadapter的构造函数
adapter构造函数

多看一看listview控件


编写代码过程中，若遇见参数什么的，点击control+左键实现构造初始化
观察参数成分
阅读代码的习惯。。不要习惯依赖性

Java中最重要的不是从网上找答案，而是从源码中找到函数、参数……就是积木拼接，
最终要达到了然每个函数名的参数、作用、实现代码







### Adapter数据适配器     将各种数据以合适的形式绑定到控件上

**ArrayAdapter**：支持泛型操作，最简单的一个Adapter，只能展现一行文字

**SimpleAdapter**：同样具有良好扩展性的一个Adapter，可以自定义多种效果

**BaseAdapter**：抽象类，实际开发中我们会继承这个类并且重写相关方法，用得最多的一个Adapter









接口与类的区别：
1、接口类似于类，但接口的成员都没有执行方式，它只是方法、属性、事件和索引的组合而已，并且也只能包含这四种成员；类除了这四种成员之外还可以有别的成员(如字段)。
2、不能实例化一个接口，接口只包括成员的签名；而类可以实例化(abstract类除外)。
3、接口没有构造函数，类有构造函数。
4、接口不能进行运算符的重载，类可以进行运算符重载。
5、接口的成员没有任何修饰符，其成员总是公共的，而类的成员则可以有修饰符(如：虚拟或者静态)。
6、派生于接口的类必须实现接口中所有成员的执行方式，而从类派生则不然。



extends与implement的区别：
在类的声明中，通过关键字extends来创建一个类的子类。


一个类通过关键字implements声明自己使用一个或者多个接口。


extends 是继承某个类, 继承之后可以使用父类的方法, 也可以重写父类的方法;


implements 是实现多个接口, 接口的方法一般为空的, 必须重写才能使用 



synchronized 关键字，代表这个方法加锁,相当于不管哪一个线程（例如线程A），
运行到这个方法时,都要检查有没有其它线程B（或者C、 D等）正在用这个方法(或者该类的其他同步方法)，
有的话要等正在使用synchronized方法的线程B（或者C 、D）运行完这个方法后再运行此线程A,
没有的话,锁定调用者,然后直接运行。它包括两种用法：synchronized 方法和 synchronized 块。



学习AsyncTask异步任务



runnnable与thread的区别
runnable是接口
thread是类
在线程使用过程中，我们肯定会用到Runnable与Thread，前者的实现方式是实现其接口即可，
后者的实现方式是继承其类。两者实现方式带来最明显的区别就是，由于Java不允许多继承，
因此实现了Runnable接口可以再继承其他类，但是Thread明显不可以。



Java不允许多继承




红黑树
1. 节点是红色或者黑色 
2. 根节点是黑色
3. 每个叶子的节点都是黑色的空节点(NULL）
4、每个红色节点的两个子节点是黑色
5、从任意节点到他的每个叶子结点的所有路径包涵相同的黑色节点
网址讲解：http://www.360doc.com/content/18/0904/19/25944647_783893127.shtml




组织数据的几种结构：
链表linked-list  线性表  数组
|
|
数据块和下一个数据地址





哈希表结合了数组和链表的优点，又称为散列表
左面为数组快速找到位置
右面为链表





Java中map类、
存储 键——值  key-value
他们具有映射关系
一一对应关系
他并不是地图的意思


synchronized(同步的)、asynchronized(异步的)、 





hashCode是jdk根据对象的地址或者字符串或者数字算出来的int类型的数值 

hashCode是用于查找使用的，而equals是用于比较两个对象的是否相等的

equal是对象相等，hashcode是返回的整数相等

equals和==的区别
==用于比较引用和比较基本数据类型时具有不同的功能：
比较基本数据类型，如果两个值相同，则结果为true
而在比较引用时，如果引用指向内存中的同一对象，结果为true;

equals()作为方法，实现对象的比较。由于==运算符不允许我们进行覆盖，也就是说它限制了我们的表达。因此我们复写equals()方法，达到比较对象内容是否相同的目的。而这些通过==运算符是做不到的。



同步传输是以数据块为传输单位

异步传输是以字节为传输单位

同步两个同步就是你叫我去吃饭，我听到了就和你去吃饭；如果没有听到，你就不停的叫，直到我告诉你听到了，才一起去吃饭。

异步就是你叫我，然后自己去吃饭，我得到消息后可能立即走，也可能等到下班才去吃饭。





Thread 是类，且实现了Runnable接口。



线程池用于解决创建线程和销毁线程的时间

threadpoolexecutor



使用过AsyncTask 的同学都知道一个异步加载数据最少要重写以下这两个方法：

- doInBackground(Params…) 后台执行，比较耗时的操作都可以放在这里。注意这里不能直接操作UI。此方法在后台线程执行，完成任务的主要工作，通常需要较长的时间。在执行过程中可以调用publicProgress(Progress…)来更新任务的进度。
- onPostExecute(Result)  相当于Handler 处理UI的方式，在这里面可以使用在doInBackground 得到的结果处理操作UI。 此方法在主线程执行，任务执行的结果作为此方法的参数返回



java中创建类，自写自己的方法，并且可以重写继承的类的方法



java 泛型：类型参数化   	比如 ArrayList<string>

多个不同的类型，实质是相同的基本类型





control+alt+方向键：快速回到上一页或下一页



集合collection是最顶端的接口，下辖list和set，其他所有集合类继承这个接口

1.	List
   实现类：ArrayList、Vector、LinkedList
  2.	Set
   实现类：HashSet、TreeSet



java多态，通过接口实现同一个行为有不同的表现形式或形态

继承	重写	父类引用指向子类对象	重载

当需要在子类中调用父类的被重写方法时，要使用 super 关键字。在子类中调用父类被重写的方法

要想调用父类中被重写的方法，则必须使用关键字 **super**。

重写方法必须在父类中出现方法名



重载：

- 被重载的方法必须改变参数列表(参数个数或类型不一样)；
- 被重载的方法可以改变返回类型；
- 被重载的方法可以改变访问修饰符；
- 被重载的方法可以声明新的或更广的检查异常；
- 方法能够在同一个类中或者在一个子类中被重载。
- 无法以返回值类型作为重载函数的区分标准。





流的分类

字符流和字节流

![	](D:\我的文件\流.jpeg)



T:控件的定义在类下面定义，可控制全局，但是绑定等 实例化操作必须在函数体中执行，否则会报错

​	我们先找到一个专门用于操作的文件的Writer子类的对象，FileWriter。后缀名是父类名，前缀名是该流对象的功能。

> new FileWriter(Strings Filename);





​		//刷新流对象中的缓冲中的数据
​		//将数据刷到目的地中
​		//fw.flush

		//关闭流资源，但是关闭之前会刷新一次内部的缓冲中的数据。
		//将数据刷到目的地中去。
		//和flush区别：flush 刷新后，流可以继续使用，close刷新后，会将流关闭。
		fw.close();
		close方法中包括了flush功能，只不过多了个关闭功能，


字节流与字符流主要的区别是他们的的处理方式
字节流是最基本的，采用ASCII编码,所有的InputStream和OutputStream的子类都是,主要用在处理二进制数据，它是按字节来处理的
但实际中很多的数据是文本，又提出了字符流的概念，采用Unicode编码.它是按虚拟机的encode来处理，也就是要进行字符集的转化
这两个之间通过 InputStreamReader,OutputStreamWriter来关联，实际上是通过byte[]和String来关联

1)字节流操作的基本单元为字节；字符流操作的基本单元为Unicode码元。 
2)字节流默认不使用缓冲区；字符流使用缓冲区。 
3)字节流通常用于处理二进制数据，实际上它可以处理任意类型的数据，但它不支持直接写入或读取Unicode码元；字符流通常处理文本数据，它支持写入及读取Unicode码元。

4)底层设备永远只接受字节数据，有时候要写字符串到底层设备，需要将字符串转成字节再进行写入。字符流是字节流的包装，字符流则是直接接受字符串，它内部将串转成字节，再写入底层设备，这为我们向IO设别写入或读取字符串提供了一点点方便。



流框架：

Flume,Logstash，kafka,Storm, SparkStreaming

1.storm 2.IComponent接口3.SparkStreaming

```javascript
处理的数据单位不同，可分为：字符流，字节流
2.数据流方向不同，可分为：输入流，输出流
3.功能不同，可分为：节点流，处理流，过滤流
```

节点流类型常见的有：   对文件操作的字符流有FileReader/FileWriter，字节流有FileInputStream/FileOutputStream。

处理流类型常见的有：   

缓冲流：缓冲流要“套接”在相应的节点流之上，对读写的数据提供了缓冲的功能，提高了读写效率，同时增加了一些新的方法。

  字节缓冲流有BufferedInputStream/BufferedOutputStream，字符缓冲流有BufferedReader/BufferedWriter，字符缓冲流分别提供了读取和写入一行的方法ReadLine和NewLine方法。   对于输出地缓冲流，写出的数据，会先写入到内存中，再使用flush方法将内存中的数据刷到硬盘。所以，在使用字符缓冲流的时候，一定要先flush，然后再close，避免数据丢失。

**转换流：用于字节数据到字符数据之间的转换。**   仅有字符流InputStreamReader/OutputStreamWriter。其中，InputStreamReader需要与InputStream“套接”，OutputStreamWriter需要与OutputStream“套接”。

**数据流：提供了读写Java中的基本数据类型的功能。**   DataInputStream和DataOutputStream分别继承自InputStream和OutputStream，需要“套接”在InputStream和OutputStream类型的节点流之上。

**对象流：用于直接将对象写入写出。**   流类有ObjectInputStream和ObjectOutputStream，本身这两个方法没什么，但是其要写出的对象有要求，该对象必须实现Serializable接口，来声明其是可以序列化的。否则，不能用对象流读写。



InputStream是字节输入流，同时也是抽象类，只提供方法声明，不提供方法的具体实现。
FileInputStream 是InputStream子类



**转换**

虽然Java支持字节流和字符流，但有时需要在字节流和字符流两者之间转换。

InputStreamReader和OutputStreamWriter，这两个为类是字节流和字符流之间相互转换的类。

　　InputSreamReader用于将一个字节流中的字节解码成字符：

　　有两个构造方法：

　　　　InputStreamReader(InputStream in);

　　　　功能：用默认字符集创建一个InputStreamReader对象

　　　　InputStreamReader(InputStream in,String CharsetName);

　　　　功能：接收已指定字符集名的字符串，并用该字符创建对象

　　OutputStreamwriter用于将写入的字符编码成字节后写入一个字节流。

　　同样有两个构造方法：

　　　　OutputStreamWriter(OutputStream out);

　　　　功能：用默认字符集创建一个OutputStreamWriter对象；

　　　　OutputStreamWriter(OutputStream out,String  CharSetName);

　　　　功能：接收已指定字符集名的字符串，并用该字符集创建OutputStreamWrite对象

​      为了避免频繁的转换字节流和字符流，对以上两个类进行了封装。

　　BufferedWriter类封装了OutputStreamWriter类；

　　BufferedReader类封装了InputStreamReader类；

　　封装格式：

　　BufferedWriter out=new BufferedWriter(new OutputStreamWriter(System.out));

　　BufferedReader in= new BufferedReader(new InputStreamReader(System.in);

　　利用下面的语句，可以从控制台读取一行字符串：

　　BufferedReader in=new BufferedReader(new InputStreamReader(System.in));

　　String line=in.readLine();





​	缓冲区可以简单地理解为一段内存区域。可以简单地把缓冲区理解为一段特殊的内存。某些情况下，如果一个程序频繁地操作一个资源（如文件或数据库），则性能会很低，此时为了提升性能，就可以将一部分数据暂时读入到内存的一块区域之中，以后直接从此区域中读取数据即可，因为读取内存速度会比较快，这样可以提升程序的性能。在字符流的操作中，所有的字符都是在内存中形成的，在输出前会将所有的内容暂时保存在内存之中，所以使用了缓冲区暂存数据。如果想在不关闭时也可以将字符流的内容全部输出，则可以使用Writer类中的flush()方法完成。

​	字符流使用了缓冲区，而字节流没有使用缓冲区。







java 读取

创建一个缓冲区，大块存储地址的读取

 BufferedReader br = new BufferedReader(new InputStreamReader(System.in));

str = br.readLine();



foreach增强for循环



捕获错误不仅可以在本句写，也可以同时写在一个try里面



/**

*类、方法名的注释

*

*/



//单行注释



/*

多行注释

*/



### 

**file.separator这个代表系统目录中的间隔符，说白了就是斜线，不过有时候需要双线，有时候是单线，你用这个静态变量就解决兼容问题了。**









## **学习监听事件的自写、线程的自写-----本质都是创建类后调用**





...................................................................................................................

default 分支不需要 break 语句

当变量的值与 case 语句的值相等时，那么 case 语句之后的语句开始执行，直到 break 语句出现才会跳出 switch 语句。

当遇到 break 语句时，switch 语句终止。程序跳转到 switch 语句后面的语句执行。case 语句不必须要包含 break 语句。如果没有 break 语句出现，程序会继续执行下一条 case 语句，直到出现 break 语句。







\####正数的最高位都是 0 ，正数的值就是二进制表示的值。 ####

\####负数的最高位都是 1 ，负数的值是 取反后加一 然后加个负号得到得值。 ####

负数以补码方式存储在计算机中，负数的原码才是负数的值，原码等于补码按位取反再加一

byte  八位二进制的最大数实127，最小负数实-128



同理了，short16位最大正数是2的15次方减一，最小负数是-（2的16次方）

int同上



数组的声明

double[] myList;         // 首选的方法
或
double myList[];         //  效果相同，但不是首选方法

数组变量的声明，和创建数组可以用一条语句完成，如下所示：

```
dataType[] arrayRefVar = new dataType[arraySize];
```

另外，你还可以使用如下的方式创建数组。

```
dataType[] arrayRefVar = {value0, value1, ..., valuek};
```

 



非静态方法既可以访问静态数据成员 又可以访问非静态数据成员，而静态方法只能访问静态数据成员； 
非静态方法既可以访问静态方法又可以访问非静态方法，而静态方法只能访问静态数据方法。 
原因：因为静态方法和静态数据成员会随着类的定义而被分配和装载入内存中，而非静态方法和非静态数据成员只有在类的对象创建时在对象的内存中才有这个方法的代码段。



合并两个数组的方法

1.ArrayList.addAll

2.for(byte bt:bt1){bt2[i]=bt;i++}

3arraycopy(bt1,0bt2,0,bt1.length);

4.arrays.copyof()

5.使用ArrayUtils.addAll(Object[], Object[])方法,在包apache-commons中





标记语言的注释<!--adsfa-->

快捷键ctr+问号建







回调的思想是:

- **类A的a()方法调用类B的b()方法**
  - **类B的b()方法执行完毕主动调用类A的callback()方法**

通俗而言: 就是A类中调用B类中的某个方法C, 然后B类中反过来调用A类中的方法D, D这个方法就叫回调方法,

同步回调异步回调

异步回调即创建线程

同步回调就是平常普通的函数调用





**单例**

 就算是单例模式，我们也无法确保两个线程不会同时创建实例，最糟糕的的情况就是多个线程同时调用静态方法同时产生实例，这在多线程中是非常常见的现象。因此，我们可以在静态方法前添加synchronized关键字来迫使每个线程在进入这个方法前，要先等候别的线程离开该方法，以确保不会有多个线程同时调用该方法。





**加锁 synchronized**

给方法加锁

synchronized [关键字](https://baike.baidu.com/item/关键字/7105697)，代表这个方法加锁,相当于不管哪一个线程（例如线程A），运行到这个方法时,都要检查有没有其它线程B（或者C、 D等）正在用这个方法(或者该类的其他同步方法)，有的话要等正在使用synchronized方法的线程B（或者C 、D）运行完这个方法后再运行此线程A,没有的话,锁定调用者,然后直接运行。



static意义：

因为getBluetoothSocket()是一个静态方法，因为我们不需要通过创建实例来调用该方法，而且这里还使用了创建对象时经常使用到的方法：延迟实例化，又叫滞后初始化，利用这点，我们可以先判断程序中是否已经创建了实例，如果没有才创建实例，这样就能确保程序中永远只有一份实例了。

被static修饰的方法也叫做静态方法，因为对于静态方法来说是不属于任何实例对象的，那么就是说在静态方法内部是不能使用this的，因为既然不属于任何对象，那么就更谈不上this了。

访问：

类名.静态变量

类名.静态方法





service通过创建bind来实现活动和服务间的通信

一般命令都是写在

startService(intent)

stopService(intent);
 ``bindService(intent, conn, Context.BIND_AUTO_CREATE); 
          ``

unbindService(conn); 





intent可以专门来传递数据而不代表任何意图



scrollTo(X,Y)指的是屏幕坐标系





getX()取到以父原点为基准的X

getRawx()方法取到以屏幕原点为基准的X，raw原始原点



scrollView下只能有一个控件

TV控件的高度要和scroll的高度一致，才能保证在一个水平向上滚动



线程启动

实例化MyThread myThread = new MyThread ();



之前写的线程那样写是因为里面可以传进参数

```
class ConnectThread extends Thread{
public ConnectThread(BluetoothDevice device, OnConnectListener connectListener) {}
}
```



```
实例化ConnectThread connectThread = new ConnectThread(device, this);
```





handler

*通常我们在主线程中创建一个Handler，
\* 然后重写该Handler的handlerMessage方法，可以看到该方法传入了一个参数Message，
\* 该参数就是我们从其他线程传递过来的信息。*



synchronized [关键字](https://baike.baidu.com/item/关键字/7105697)，代表这个方法加锁,相当于不管哪一个线程（例如线程A），运行到这个方法时,都要检查有没有其它线程B（或者C、 D等）正在用这个方法(或者该类的其他同步方法)，有的话要等正在使用synchronized方法的线程B（或者C 、D）运行完这个方法后再运行此线程A,没有的话,锁定调用者,然后直接运行。



在使用handler的时候，在handler所创建的线程需要维护一个唯一的Looper对象， 每个线程对应一个Looper，每个线程的Looper通过ThreadLocal来保证Looper对象的内部又维护有唯一的一个MessageQueue，所以一个线程可以有多个handler，但是只能有一个Looper和一个MessageQueue。



### java 类

###### 大部分时候，类被定义成一个独立的程序单元。在某些情况下，也会把一个类放在另一个类的内部定义，这个定义在其他类内部的类就被称为内部类（有些地方也叫做嵌套类），包含内部类的类也被称为外部类（有些地方也叫做宿主类）



###### 1.匿名内部类

也就是没有名字的内部类

正因为没有名字，所以匿名内部类只能使用一次，它通常用来简化代码编写

但使用匿名内部类还有个前提条件：必须继承一个父类或实现一个接口





正常写法

```
abstract` `class` `Person {
    ``public` `abstract` `void` `eat();
}
```

 

```
class` `Child ``extends` `Person {
    ``public` `void` `eat() {
        ``System.out.println(``"eat something"``);
    ``}
}
```

```
public` `class` `Demo {
    ``public` `static` `void` `main(String[] args) {
        ``Person p = ``new` `Child();
        ``p.eat();
    ``}
}
```

匿名内部类写法

```
Person p = ``new` `Person() {
            ``public` `void` `eat() {
                ``System.out.println(``"eat something"``);
            ``}
        ``};
        ``p.eat();
```

我们直接将抽象类Person中的方法在大括号中实现了



#### 2.静态内部类

使用static来修饰一个内部类，则这个内部类就属于外部类本身，而不属于外部类的某个对象。称为静态内部类（也可称为类内部类），这样的内部类是类级别的，static关键字的作用是把类的成员变成类相关，而不是实例相关

注意： 
1.非静态内部类中不允许定义静态成员 
2.外部类的静态成员不可以直接使用非静态内部类 
3.静态内部类，不能访问外部类的实例成员，只能访问外部类的类成员

*** $(t) 就是输出变量 t 的值



##### 以下很重要--注释

构造器  内部类  外部类  私有

    public class Outer {
    内部类的私有方法
    private Outer() {
    
    }
    外部类构造器是私有的
    private void eat(String food) {
        System.out.println("我在吃"+food);
    }
    内部类
    class Inner{
    
        private Inner(){
    
        }
        private void go(String city){
            System.out.println("我要去"+city);
        }
    }

}

#### 构造方法

方法是可以和类名同名的,和构造方法唯一的区别就是,构造方法没有返回值

必须和类名一致

每个类的构造方法和这个类的名字本来就是一样的，例如
public class A{
		private String a；

​		public A(String b){
​		this.a=b;
​		}
}

构造函数 ，是一种特殊的方法。主要用来在创建对象时初始化对象， 即为对象[成员变量](https://baike.baidu.com/item/成员变量)赋初始值，总与new[运算符](https://baike.baidu.com/item/运算符)一起使用在创建对象的语句中。特别的一个类可以有多个构造函数 ，可根据其参数个数的不同或参数类型的不同来区分它们 即构造函数的[重载](https://baike.baidu.com/item/重载)。

..构造函数参数可有可无，有参数（目的就是为了给对象实例变量赋值）

..一个类可以有多个构造函数

..new对象时，是调用构造函数实例化，

..构造器在对象被new时执行

..类中没有构造函数时，自动创建无参数的构造函数

```
Test test = new Test（"a"）；
 //Test（"a"）其中这个就是构造函数，“a”为构造方法的形参；
```

构造函数的任务就是初始化一个对象内部的状态

普通方法：代表对象可以干什么





this调用子类 的构造方法

super调用父类的构造方法

 1） super（参数）：调用基类中的某一个构造函数（应该为构造函数中的第一条语句）
2)this（参数）：调用本类中另一种形成的构造函数（应该为构造函数中的第一条语句）
3)super:　它引用当前对象的直接父类中的成员（用来访问直接父类中被隐藏的父类中成员数据或函数，基类与派生类中有相同成员定义时如：super.变量名 super.成员函数据名（实参）
4)this：它代表当前对象名（在程序中易产生二义性之处，应使用this来指明当前对象；如果函数的形参与类中的成员数据同名，这时需用this来指明成员变量名）

5）调用super()必须写在子类构造方法的第一行，否则编译不通过。每个子类构造方法的第一条语句，都是隐含地调用super()，如果父类没有这种形式的构造函数，那么在编译的时候就会报错。
　　 6）super()和this()类似,区别是，super()从子类中调用父类的构造方法，this()在同一类内调用其它方法。
　　 7）super()和this()均需放在构造方法内第一行。
　　 8）尽管可以用this调用一个构造器，但却不能调用两个。

###### 　　 9）this和super不能同时出现在一个构造函数里面，因为this必然会调用其它的构造函数，其它的构造函数必然也会有super语句的存在，所以在同一个构造函数里面有相同的语句，就失去了语句的意义，编译器也不会通过。

　　 10）this()和super()都指的是对象，所以，均不可以在static环境中使用。包括：static变量,static方法，static语句块。
　　 11）从本质上讲，this是一个指向本对象的指针, 然而super是一个Java关键字  





#### 静态内部类  静态内部方法  外部类  外部方法调用访问规则

1）外部类可以通过创建静态内部类实例的方法来调用静态内部类的非静态属性和方法

　　　2）外部类可以直接通过“ 外部类.内部类.属性（方法）” 的方式直接调用静态内部类中的静态属性和方法

**静态内部类如何调用外部类的属性和方法**　

　　  **静态内部类如果要访问外部的成员变量或者成员方法，那么必须是静态的**

　　　1）静态内部类可以直接调用外部类的静态属性和方法

　　　2）静态内部类可以通过创建外部类实例的方法调用外部类的非静态属性和方法

**如何创建静态内部类实例**

　　**创建静态内部类的时候是不需要将静态内部类的实例对象绑定到外部类的实例对象上**

　　**静态内部类属于外部类，而不是属于外部类的对象**

　　　1）在非外部类中：外部类名.内部类名 name = new 外部类名.内部类名();

　　　2）在外部类中：内部类名 name = new 内部类名();

public class Outer {
    // 定义一个实例变量和一个静态变量
    private int a;
    private static int b;

    // 定义一个静态方法和一个非静态方法
    public static void say() {
    }
    
    public void test() {
        // 在外部类中调用内部类的属性和方法
        Outer.Inner.c = 1; // 可以通过静态内部类的全类名来调用静态内部类的静态属性（外部类名.静态内部类名.属性）
        Outer.Inner.go(); // 可以通过静态内部类的全类名来调用静态内部类的静态方法（外部类名.静态内部类名.方法）
        // Outer.Inner.walk(); //不能通过类静态内部类的全类名来调用内部类的非静态属性和方法
        Inner inner = new Inner(); //可以通过创建内部类实例来调用静态内部类的非静态属性和方法
        inner.d = 1;
        inner.walk(); 
    }
    
    // 静态内部类
    public static class Inner {
        // 在静态内部类中定义一个静态变量和一个实例变量
        static int c;
        int d;
        // 定义一个匿名代码块和一个静态代码块
        {
        }
        static {
        }
    
        // 定义一个静态方法和一个普通方法
        public static void go() {
            
        }
    
        public void walk() {
            // 在静态内部类中调用外部类的属性和方法
            int f = b; // 可以直接调用外部类的静态属性
            say(); // 可以直接调用外部类的静态方法
            // int e = a; 直接调用外部类的非静态属性出错编译出错
            // test(); 直接调用外部类的非静态方法时编译出错
            Outer outer = new Outer();
            int e = outer.a; // 可以通过创建外部类实例来调用外部类的非静态属性
            outer.test(); // 可以通过创建外部类实例来调用外部类的非静态方法
        }
    }
}







不要试图对一个已经死亡的线程调用start()方法使它重新启动，死亡就是死亡，该线程将不可再次作为线程执行。





主线程与子线程之间的

通信媒介是Handler

数据单元是message

之间的一种数据结构是消息队列（先进先出）message queue

消息的处理者是Handler

循环器looper

网站https://www.jianshu.com/p/b4d745c7ff7a



一个线程只能有一个Looper，对应一个MessageQueue

默认情况下Handler会与其被定义时所在线程的Looper绑定，比如，Handler在主线程中定义，那么它是与主线程的Looper绑定。 mainHandler = new Handler() 等价于new Handler（Looper.myLooper()）. Looper.myLooper()：获取当前进程的looper对象，类似的 Looper.getMainLooper() 用于获取主线程的Looper对象。 

 Looper.loop(); 让Looper开始工作，从消息队列里取消息，处理消息。 







#### java抽象类和普通类的区别

1.抽象类不能被实例化。

2.抽象类可以有构造函数，抽象方法不能被声明为静态。

3.抽象方法只需申明，而无需实现，抽象类中可以允许普通方法有主体

4.含有抽象方法的类必须申明为抽象类

5.抽象的子类必须实现抽象类中所有抽象方法，否则这个子类也是抽象类。









#### inflater

在实际开发中LayoutInflater这个类还是非常有用的，它的作用类似于findViewById()。不同点是LayoutInflater是用来找res/layout/下的xml布局文件，并且实例化；而findViewById()是找xml布局文件下的具体widget控件(如Button、TextView等)。









### bindService过程

https://blog.csdn.net/hdhhd/article/details/80612726

1.服务中声明mBinder

```
	private MyBinder binder = new MyBinder();  
    public class MyBinder extends Binder  
    {  
        public int getCount()  
        {  
            return count;  
        }  
    }  
      
    //以下必须实现的方法,绑定该Service时回调该方法  
    @Override  
    public IBinder onBind(Intent intent) {  
        Log.i(TAG, "onBind方法被调用!");  
        return binder;  
    }  
```

2.主活动中实例化binder

创建连接

```
 TestService2.MyBinder binder;  
    private ServiceConnection conn = new ServiceConnection() {  
          
        //Activity与Service断开连接时回调该方法  
        @Override  
        public void onServiceDisconnected(ComponentName name) {  
            System.out.println("------Service DisConnected-------");  
        }  
          
        //Activity与Service连接成功时回调该方法  
        @Override  
        public void onServiceConnected(ComponentName name, IBinder binder) {  
            System.out.println("------Service Connected-------");  
            binder = (TestService2.MyBinder) binder;  
        }  
    };  
```

3.连接

```
 bindService(intent, conn, Service.BIND_AUTO_CREATE);                  
```

4.断开连接

```
 unbindService(conn);         
```



### 在onBind方法中返回了binder对象，该对象便是LocalBinder的具体实例，而binder对象最终会返回给客户端，客户端通过返回的binder对象便可以与服务端实现交互。



### 两种特殊情况

- 先绑定服务后启动服务

    如果当前Service实例先以绑定状态运行，然后再以启动状态运行，那么绑定服务将会转为启动服务运行，这时如果之前绑定的宿主（Activity）被销毁了，也不会影响服务的运行，服务还是会一直运行下去，指定收到调用停止服务或者内存不足时才会销毁该服务。

- 先启动服务后绑定服务

    如果当前Service实例先以启动状态运行，然后再以绑定状态运行，当前启动服务并不会转为绑定服务，但是还是会与宿主绑定，只是即使宿主解除绑定后，服务依然按启动服务的生命周期在后台运行，直到有Context调用了stopService()或是服务本身调用了stopSelf()方法抑或内存不足时才会销毁服务。



**onStartCommand（Intent intent, int flags, int startId）**







IPC--进程之间通信







binder绑定Service

Handler处理活动与线程之间的通信

bundle





adapter可以继承并重写方法





#### service:

onBind(...)函数是Service基类中的唯一抽象方法，子类都必须重写实现，此函数的返回值是针对Bound Service类型的Service才有用的，在Started Service类型中，此函数直接返回 null 即可。



可以有多个客户端绑定到一个服务端，但是Android系统只会在第一个客户端绑定服务端时，调用service的onBind()方法去获取IBinder对象。之后系统会传递这个IBinder到绑定服务端的其他客户端（这时是不会再次调用onBind()方法的）。





我们总结一下如果想让Service支持bindService调用方式，Service需要做以下事情: 
1. 在Service的onBind方法中返回IBinder类型的实例。 
2. onBind方法返回的IBinder的实例需要能够返回Service实例本身或者通过binder暴露出Service公共方法。通常情况下，最简单明了的做法就是将binder弄成Service的内部类，然后在binder中加入类似于getService之类的方法返回包含binder的Service，这样client可以通过该方法得到Service实例。

### service声明周期

##### context.startService() 启动流程：

context.startService()  -> onCreate()  -> onStart()  -> Service running  -> context.stopService()  -> onDestroy()  -> Service stop 

##### context.bindService()启动流程：

context.bindService()  -> onCreate()  -> onBind()  -> Service running  -> onUnbind()  -> onDestroy()  -> Service stop

##### context.startService() 启动再context.bindService()启动：

context.startService()  -> onCreate()  ->onBind() -> Service running  ->  onUnbind()  ->context.stopService()  -> onDestroy()  -> Service stop 

先startService()再context.bindService()的话必须context.stopService() 和 context.onUnbind()都调用才可以停止服务















- **onStartCommand()**
- **onStartCommand（Intent intent, int flags, int startId）**

  当另一个组件（如 Activity）通过调用 startService() 请求启动服务时，系统将调用此方法。一旦执行此方法，服务即会启动并可在后台无限期运行。 如果自己实现此方法，则需要在服务工作完成后，通过调用 stopSelf() 或 stopService() 来停止服务。（在绑定状态下，无需实现此方法。）

参数含义：

- intent ：启动时，启动组件传递过来的Intent，如Activity可利用Intent封装所需要的参数并传递给Service
- flags：表示启动请求时是否有额外数据，可选值有 0，START_FLAG_REDELIVERY，START_FLAG_RETRY，0代表没有，它们具体含义如下：
  - START_FLAG_REDELIVERY 
    这个值代表了onStartCommand方法的返回值为 
    START_REDELIVER_INTENT，而且在上一次服务被杀死前会去调用stopSelf方法停止服务。其中START_REDELIVER_INTENT意味着当Service因内存不足而被系统kill后，则会重建服务，并通过传递给服务的最后一个 Intent 调用 onStartCommand()，此时Intent时有值的。
  - START_FLAG_RETRY 
    该flag代表当onStartCommand调用后一直没有返回值时，会尝试重新去调用onStartCommand()。
- startId ： 指明当前服务的唯一ID，与stopSelfResult (int startId)配合使用，stopSelfResult 可以更安全地根据ID停止服务。

  实际上onStartCommand的返回值int类型才是最最值得注意的，它有三种可选值， START_STICKY，START_NOT_STICKY，START_REDELIVER_INTENT，它们具体含义如下：

- START_STICKY 
    当Service因内存不足而被系统kill后，一段时间后内存再次空闲时，系统将会尝试重新创建此Service，一旦创建成功后将回调onStartCommand方法，但其中的Intent将是null，除非有挂起的Intent，如pendingintent，这个状态下比较适用于不执行命令、但无限期运行并等待作业的媒体播放器或类似服务。
- START_NOT_STICKY 
    当Service因内存不足而被系统kill后，即使系统内存再次空闲时，系统也不会尝试重新创建此Service。除非程序中再次调用startService启动此Service，这是最安全的选项，可以避免在不必要时以及应用能够轻松重启所有未完成的作业时运行服务。
- START_REDELIVER_INTENT 
    当Service因内存不足而被系统kill后，则会重建服务，并通过传递给服务的最后一个 Intent 调用 onStartCommand()，任何挂起 Intent均依次传递。与START_STICKY不同的是，其中的传递的Intent将是非空，是最后一次调用startService中的intent。这个值适用于主动执行应该立即恢复的作业（例如下载文件）的服务。











eventbus传递消息的一种方法















服务中主动向主线程中传递消息，消息回调













不论是Binder启动还是AIDL启动服务都要写

ServiceConnection conn = new ServiceConnection() {
        @Override
        public void onServiceConnected(ComponentName name, IBinder service) {
            bluetoothService = IBluetoothAIDL.Stub.asInterface(service);//传进的IBinder转成			AIDL接口
        }
        @Override
        public void onServiceDisconnected(ComponentName name) {
            bluetoothService = null;
        }
    };







###### 

#####   Android操作系统尝试尽可能长时间的保持应用的进程，但 当可用内存很低时最终要移走一部分进程。怎样确定那些程序可以运行，那些要被销毁，Android让每一个进程在一个重要级的基础上运行，重要级低的进程 最有可能被淘汰，一共有5级，下面这个列表就是按照重要性排列的：

1 一个前台进程显示的是用户此时需要处理和显示的。下列的条件有任何一个成立，这个进程都被认为是在前台运行的。
        a 与用户正发生交互的。
        b 它控制一个与用户交互的必须的基本的服务。
        c 有一个正在调用生命周期的回调函数的service（如onCreate()、onStar()、onDestroy()）
        d 它有一个正在运行onReceive()方法的广播接收对象。
	只有少数的前台进程可以在任何给定的时间内运行，销毁他们是系统万不得已的、最后的选择——当内存不够系统继续运行下去时。通常，在这一点上，设备已经达到了内存分页状态，所以杀掉一些前台进程来保证能够响应用户的需求。

2 一个可用进程没有任何前台组件，但它仍然可以影响到用户的界面。下面两种情况发生时，可以称该进程为可用进程。
          它是一个非前台的activity，但对用户仍然可用（onPause()方法已经被调用）这是可能发生的，例如：前台的activity是一个允许上一 个activity可见的对话框，即当前activity半透明，能看到前一个activity的界面，它是一个服务于可用activity的服务。

3 一个服务进程是一个通过调用startService()方法启动的服务，并且不属于前两种情况。尽管服务进程没有直接被用户看到，但他们确实是用户所关心的，比如后台播放音乐或网络下载数据。所以系统保证他们的运行，直到不能保证所有的前台可见程序都正常运行时才会终止他们。

4 一个后台进程就 是一个非当前正在运行的activity（activity的onStop()方法已经被调用），他们不会对用户体验造成直接的影响，当没有足够内存来运 行前台可见程序时，他们将会被终止。通常，后台进程会有很多个在运行,所以他们维护一个LRU最近使用程序列表来保证经常运行的activity能最后一 个被终止。如果一个activity正确的实现了生命周期的方法，并且保存它当前状态，杀死这些进程将不会影响到用户体验。

5 一个空线程没有运行任何可用应用程序组，保留他们的唯一原因是为了设立一个缓存机制，来加快组件启动的时间。系统经常杀死这些内存来平衡系统的整个系统的资源，进程缓存和基本核心缓存之间的资源。Android把进程里优先级最高的activity或服务，作为这个进程的优先级。例如，一个进程拥有一个服务和一个可见的activity，那么这个进程将会被定义为可见进程，而不是服务进程。此 外，如果别的进程依赖某一个进程的话，那么被依赖的进程会提高优先级。一个进程服务于另一个进程，那么提供服务的进程不会低于获得服务的进程。例如，如果 进程A的一个内容提供商服务于进程B的一个客户端，或者进程A的一个service被进程B的一个组件绑定，那么进程A至少拥有和进程B一样的优先级，或 者更高。因为一个运行服务的进程的优先级高于运行后台activity的进程，一个activity会准备一个长时间运行的操作来启动一 个服务，而不是启动一个线程–尤其是这个操作可能会拖垮这个activity。例如后台播放音乐的同时，通过照相机向服务器发送一张照片，启动一个服务会 保证这个操作至少运行在service  进程的优先级下，无论这个activity发生了什么，广播接收者应该作为一个空服务而不是简单的把耗时的操作单独放在一个线程里。   













## AIDL

（Android Interface Definition Language）是Android接口定义语言的意思，它可以用于让某个Service与多个应用程序组件之间进行跨进程通信，从而可以实现多个应用程序共享同一个Service的功能。

AIDL是一个缩写，android Interface Definition Language，也就是Android接口定义语言。是的，首先我们知道的第一点就是：AIDL是一种语言。











#### unreachable　statement报错

java编译器把unreachable　statement标记为运行时错误，就是编译器决定永远不会执行它。 
下面的几种情况会出现 unreachable statement： 
（1）在reutrn语句后写语句。 
（2）在throw语句后写语句。 
（3）break、continue语句之后定义语句。 
（4）“\u10100”//合法，相当于‘\u1010’和字符串“0”。 
（5）移位运算符可以用于long int char short byte。 
（6）类的访问控制符可以是public或什么都不加。 
（7）goto是保留字但不是关键字。then什么都不是。 
（8）把超类的类型强制转换后赋给子类的对象时，编译无异常，但运行时会出现异常。







##### 快捷键：F8调试下一行，debug



service中的命令写在onbind()的下面









aysnctask轻量级异步任务类









#### 向上转型

子类转型成父类是向上转型，反过来说，父类转型成子类就是向下转型。



``在继承关系上，我们设计时通常在继承树上把父类画在上，子类在下，由于这种转型是沿着继承树往上走，所以我们把它称为–**向上转型**。但是，

Pet mybaby = new Dog{}

myBaby.play()；成功

myBaby.bark();失败

 **向上转型会丢失子类的新增方法，同时会保留子类重新的方法。**









``我们先使用Pet类型的myBaby指向了狗对象，然后再换成Dog类型的snoopy去指向同一个狗对象。前者由于是父类型所以只能看到定义在父类的方法，后者是子类型，当然就可以看到狗对象身上的特有行为了。这种转型是从父类引用转为子类引用，从继承树的角度说就是**向下转型**。

Pet mybaby = new Dog{}

myBaby.play()；成功

Dog snoopy = (Dog)myBaby;

myBaby.bark();

会存在强制转换风险性



**如果向下转型想要编译和运行都成功，必须使用强制转型语法，还必须要求运行起来父类引用确实指向该子类的对象**



在强制转换前进行判断

if（myBaby instanceof Dog）{

//命令

}



**结论**

1在引用数据类型中，只有有继承关系的类型才能进行类型转换；

2类型转换只是转换看待对象的引用的类型，对象本身没有也不可能参与转换；

3父类引用可以自动指向子类对象，但只能访问和调用到来自于父类的属性和行为；. 

4.子类的引用不能指向父类或其它子类对象，就算强转也会导致运行失败并抛出ClassCastException；

5. 把父类引用赋给子类引用，语法上必须使用强制类型转换，要想运行也成功还必须保证父类引用指向的对象一定是该子类对象（最好使用instance判断后，再强转）。





parcel用来存放数据的容器









LayoutInflater

这个类还是非常有用的，它的作用类似于findViewById()。不同点是LayoutInflater是用来找res/layout/下的xml布局文件，并且实例化；

findViewById()是找xml布局文件下的具体widget控件(如Button、TextView等)。

获得 LayoutInflater 实例的三种方式

1. LayoutInflater inflater = getLayoutInflater();//调用Activity的getLayoutInflater()
2. LayoutInflater inflater = LayoutInflater.from(context);
3. LayoutInflater inflater = (LayoutInflater)context.getSystemService









\r ： return 到当前行的最左边。

\n： newline 向下移动一行，并不移动左右

有些系统中\r\n才能达到换行重新开始的效果









通配符：**?** 通配符匹配文件名中的 0 个或 1 个字符，而 ***** 通配符匹配零个或多个字符。

#### 正则表达式：

var str = "123abc";
var patt1 = /^[0-9]+abc$/;
document.write(str.match(patt1));

^开始标志

[0-9]+abc

$结束标志











循环中的方式：增强for循环













onclick方法的五种实现方式

1.

```java
Button bt_Demo = (Button)findViewById(R.id.bt_Demo);
 bt_Demo.setOnClickListener(new OnClickListener() {
  @Override
  public void onClick(View v) {
       //具体点击操作的逻辑
  }
 });
```

2.

```java
Button[] demoBtns ;
……
for(Button button : demoBtns ){
     button.setOnClickListener(listener);
}
  
 private OnClickListener listener = new OnClickListener(){ 
  @Override
  public void onClick(View arg0) {
    // TODO Auto-generated method stub  
    switch(arg0.getId()){ 
     case R.id.btn_Demo:
           //具体点击操作的逻辑
           break;
     default:
           break;
     }
  }
 }
```

3.

```java
Button bt_Demo = (Button)findViewById(R.id.bt_Demo);
 bt_Demo.setOnClickListener(new ButtonListener());
 private class ButtonListener implements OnClickListener{
  @Override
  public void onClick(View arg0) {
      // TODO Auto-generated method stub  
     switch(arg0.getId()){ 
     case R.id.btn_Demo:
           //具体点击操作的逻辑
           break;
     default:
           break;
     }
  }  
 }
```

4.

```java
 public class MyActivity extends Activity implements OnClickListener {
   @Override 
   public void onCreate(Bundle savedInstanceState) {
      super.onCreate(savedInstanceState);
      setContentView(R.layout.main);
      //按纽
      Button btn_Demo = (Button)findViewById(R.id.bt_Demo);
      bt_Demo.setOnClickListener(this); 
   ｝
    
   @Override 
   public void onClick(View v) {
     switch(arg0.getId()){ 
     case R.id.btn_Demo:
           //具体点击操作的逻辑
           break;
     default:
           break;
     }
    }
 ｝
```

5.

```csharp
<TextView
         android:layout_width="match_parent"
         android:layout_height="wrap_content"
         android:clickable="true"
         android:onClick="onTextViewClick"
         android:text="点击事件"
         android:textSize="16sp" />

//在代码中实现onTextViewClick()方法即可。
public void onTextViewClick(){
    //具体点击操作的逻辑
}
```









button有点击事件和触摸事件









java中@作用

他是java注解（标注）









### java标注

https://www.2cto.com/kf/201810/782776.html

1. @Override:只能用在方法之上的，用来告诉别人这一个方法是改写父类的。
2. @Deprecated:建议别人不要使用旧的API的时候用的,编译的时候会用产生警告信息,可以设定在程序里的所有的元素上.
3. @SuppressWarnings:这一个类型可以来暂时把一些警告信息消息关闭.

允许我们自定义标注

元注解：主要有四个@Target,@Retention,@Documented,@Inherited



**这样的注释功能类似于间接调用函数，将复杂的过程屏蔽掉，然后绕了一圈调用函数**





### 多线程：

 1.定义实现Runnable接口

 2.覆盖Runnable接口中的run方法，将线程要运行的代码存放在run方法中。

3.通过Thread类建立线程对象。

4.将Runnable接口的子类对象作为实际参数传递给Thread类的构造函数。

  为什么要讲Runnable接口的子类对象传递给Thread的构造方法。因为自定义的方法的所属的对象是Runnable接口的子类对象。

5.调用Thread类的start方法开启线程并调用Runnable接口子类run方法。

```
class` `Bank{ 
 
  ``private` `int` `sum; 
  ``public` `void` `add(``int` `n){ 
   
     ``sum+=n; 
     ``System.out.println(``"sum="``+sum); 
   
  ``} 
 
} 
 ``class` `Cus ``implements` `Runnable{ 
 
  ``private` `Bank b=``new` `Bank(); 
  ``public` `void` `run(){ 
   ``synchronized``(b){   
     ``for``(``int` `x=``0``;x<``3``;x++) 
     ``{ 
      ``b.add(``100``); 
      
     ``} 
   ``} 
  ``} 
 
} 
public` `class` `BankDemo{ 
  ``public` `static` `void` `main(String []args){ 
    ``Cus c=``new` `Cus(); 
    ``Thread t1=``new` `Thread(c); 
    ``Thread t2=``new` `Thread(c); 
    ``t1.start(); 
    ``t2.start(); 
   
   
  ``} 
 
 
}
```













@FunctionalInterface

interface IConvert<F, T> {

​    T convert(F form);

}

（@FunctionalInterface 注解要求接口有且只有一个抽象方法，JDK中有许多类用到该注解，比如 Runnable，它只有一个 Run 方法。）

观察接口 IConvert，传参为类型 F，返回类型 T。









###  通过“：：”访问类的构造方法，对象方法，静态方法

访问静态方法

// static methods
IConvert<String, String> convert = Something::startsWith;
String converted = convert.convert("123");

访问对象方法

// object methods
Something something = new Something();
IConvert<String, String> converter = something::endWith;
String converted = converter.convert("Java");

访问构造方法

// constructor methods
IConvert<String, Something> convert = Something::new;
Something something = convert.convert("constructors");





### java中“->”指代的是java自动翻译













### 接口及继承关系

一个类只能extends一个父类，但可以implements多个接口。java通过使用接口的概念来取代C++中多继承。与此同时，一个接口则可以同时extends多个接口，却不能implements任何接口。因而，Java中的接口是支持多继承的。

当编译器在实现接口的时候会依然检查接口InterfaceMultiInheritance.java、TestInterfaceA.java和TestInterfaceB.java中的方法声明，如果后两者有与前者相冲突的方法声明，编译器将只要求类实现前者的声明，而后两者中相同的方法声明将自动被忽略。而当只有后两者中有相同的方法声明时，编译器将实现其中的一个即可。就好像是编译器中有一个专门存储方法声明的Set一样，在有继承关系的接口中，只保存一次相同的方法声明。











### baseadapter

建立之前需要创建每个列表项的子布局，就是每个listview中item显示布局

新建类继承baseadapter需要重写几个方法，getcount(),getView(),*界面上有多少列就会调用多少次getView*

新建viewholder类方便复用，避免添加数据重复哦匹配控件

可以在自定义的adapter中编写我们想要的函数：add,cancel,







### 错误：

Attempt to invoke virtual method 'void android.widget.TextView.setText(java.lang.CharSequence)' on a null object reference

可能原因：

1.这个null异常通常是找不到该Layout中的TextView组件，检查layout和初始化组件是否有误

2.这个异常是说你调用setText方法的这个TextView对象是null的，你得检查一下给这个对象赋值的地方是否有问题，是不是没执行？是不是findViewById时ID不对？

### 总结

凡是遇见方法内指针为空时，要考虑到是否是此方法前的控件为空











日志中存在标签便于侦听







安卓中的广播具有优先级，有序广播，标准广播

优先级越高的广播接收器可以先收到广播





ctr+alt+L 快捷自动排序









# java利用反射实现与@Onclick(R.id.button)类似的功能示例









```
Class<? extends Activity>
```

指的是继承了Activity的所有class，

```
Class<? extends Activity> atc ;
```







### java回调机制

##### 接口回调

现有一个**接口A**,和它的**实现类A1**,和另外一个有接口A引用的**类B**,因为类B中有**接口A**的引用,在B执行完方法后,可以通过接口A的引用,告诉A执行完成了这个方法.由于A是一个接口,所以具体接收执行完成这个方法在它是**实现类A1**中体现.



在android中回调机制被大量的使用。比如，在Activity中定义了很多生命周期的不同状态要调用的方法，这些方法都是空实现，系统框架要调用，用户也要调用来实现。

```
button.setOnClickListener(new OnClickListener(){ 
@Override            
public void onClick(View v){
	}         
});
```



**例子：**

public interface BackInterface {
	void backMethod();
}
然后定义一个实现类Teacher,功能是让学生做课堂练习,接收学生做完课堂练习的通知	

	public class Teacher implements BackInterface {
	//因为老师要告诉学生做课堂练习,所以这个传一个学生的引用
	private Student student;
	
	public Teacher(Student student){
		this.student = student;
	}
	//老师告诉学生做课堂练习
	public void doEvent(){
		System.out.println("老师让学生做练习...");
		student.doPractice(this);
	}
	//用于接收接口回调的消息
	@Override
	public void backMethod() {
		System.out.println("老师接收到学生做完课堂练习的消息");
	}

}
学生类,功能是做练习,做完之后并告诉老师(回调)

	public class Student {
	//学生做课堂练习,并告诉老师
	public void doPractice(BackInterface BackInterface) {
		System.out.println("学生做练习...");
		System.out.println("学生告诉老师做完练习...");
		BackInterface.backMethod();
	}
	}

### 接口是不能实例化的，不过可以声明一个接口的引用变量，让它指向一个类的实例，当然那个类要实现了那个接口的

声明一个接口的变量（接口的引用）可以指向一个实现类（实现该接口的类）的实例，

但是该接口的变量不能使用实现类中有，接口中没有的方法（实现类中没有重写的方法，自添加的方法），





### 多态

一，使用父类类型的引用指向子类的对象;

二，该引用只能调用父类中定义的方法和变量;

三，如果子类中重写了父类中的一个方法，那么在调用这个方法的时候，将会调用子类中的这个方法;（动态连接，动态调用）;

四，变量不能被重写（覆盖）， “重写” 的概念只针对方法，如果在子类中 “重写” 了父类中的变量，那么在编译时会报错。



Java中并不是任意引用数据类型之间都能进行强制转换

父类引用指向子类对象可以，但是只能调用来自父类的属性和方法

继承关系是**is a**的关系

#### 向上转型：沿着继承树向上走

pet baby = new Dog();

向下转型：沿着继承树向下走

Dog snooby = (dog)baby()

向上向下指的是对象给谁，是往上走还是往下赋

### 多态总结

在引用数据类型中，只有有继承关系的类型才能进行类型转换；

类型转换只是转换看待对象的引用的类型，对象本身没有也不可能参与转换；

父类引用可以自动指向子类对象，但只能访问和调用到来自于父类的属性和行为；

. 子类的引用不能指向父类或其它子类对象，就算强转也会导致运行失败并抛出ClassCastException；

. 把父类引用赋给子类引用，语法上必须使用强制类型转换，要想运行也成功还必须保证父类引用指向的对象一定是该子类对象（最好使用instance判断后，再强转）。





### 重要：接口的引用变量指向类的实例

可以不用在此类中实现接口方法的实现，通过指向定位到实现方法的类

```
OnConnectListener onConnectListener = new BluetoothServiceTest();
```





### 数组

java中数组的声明必须指定数组的长度

否则会造成资源的浪费



List是一个接口，而ArrayList是List接口的一个实现类。 

​       ArrayList类继承并实现了List接口。 

​       因此，List接口不能被构造，也就是我们说的不能创建实例对象，但是我们可以像下面那样为List接口创建一个指

向自己的对象引用，而ArrayList实现类的实例对象就在这充当了这个指向List接口的对象引用。 

 

List list;//正确，list = null; 

List list = new List();//是错误的用法

 List list = new ArrayList();这句创建了一个ArrayList实现类的对象后把它上溯到了List接口。此时它就是一个List对

象了，它有些ArrayList类具有的，但是List接口没有的属性和方法，它就不能再用了。 而ArrayList list=newArrayList();

创建一对象则保留了ArrayList的所有属性和方法。 









### 蓝牙多次连接出现错误总结：

​	 BluetoothServerSocket 必须要及时关闭，就是客户端连上服务端之后，马上调用close()方法。





逻辑运算

P且q 全真则真 有假则假
p或q 有真则真 全假则假
非P p真则假 p假则真





### 时刻记住程序的执行步骤：要考虑线程、异步问题







### 对象引用与对象的实例化

T1 a= new T1();

T1 的一个 对象的引用 a  指向了堆空间里的一个新T1对象

a是引用

T1是对象

通过对象的引用使用对象

有一种叫临时对象，用完即舍弃。如：print{“你好”}

这里的“你好”就是临时对象



实例化

创建对象

B b = new B()

包括四个步骤：

1）右边的“new B”，是以B类为模板，在堆空间里创建一个B类对象（也简称为B对象）。

2）末尾的()意味着，在对象创建后，立即调用Vehicle类的构造函数，对刚生成的对象进行初始化。构造函数是肯定有的。如果你没写，Java会给你补上一个默认的构造函数。

3）左边的“B b”创建了一个B类的构造函数。所谓B类引用，就是以后可以用来指向B对象的对象引用。

4）“=”操作符使对象引用指向刚创建的那个B对象。

###### 所以你要让一个类防止被实例化，就需要对这个类的构造方法使用private修饰符

例如：

```csharp
private class B{
    public void print(){
        System.out.println("Hello,World!");
    }
```





##### 继承问题

被private修饰的，是不可以被继承的，因为private修饰的只能在本类中可见，子类是不可见的；另外父类被protected或public修饰的，子类是可以继承的；被默认修饰符修饰的只能在同包下的子类是可以继承的；









### 理解单例

###### 单例获取instance再使用方法

Singleton.getinstance.set...

Singleton.getinstance.get...



正解：

    private static BluetoothSocketHandler instance = new BluetoothSocketHandler();
    
    private volatile BluetoothSocket socket;
    
    private BluetoothSocketHandler(){}
    
    public static BluetoothSocketHandler getInstance(){
        return instance;
    }
    
    public void setSocket(BluetoothSocket socket){
        this.socket = socket;
    }
    
    public BluetoothSocket getSocket(){
        return socket;
    }
错误：

    private volatile static BluetoothSocket socket;
    private BluetoothSocket SingletonBluetoothSocket(){
        return socket;
    };
    
    public void setSocket(BluetoothSocket socket){
        this.socket = socket;
    }
    
    public static BluetoothSocket getSocket(){
        return socket;
    }




单例的感悟：

吸取单例这种思想；

并不是要用类名来调用它的方法，可是得到它的实例，通过它的实例调用方法











lambda表达式，相当于无名称的函数，
最简单的例子是 Collections.sort(list, (x, y) -> y - x); 其中

(x, y) -> y - x

是一个lambda表达式，输入两个参数x, y，返回值 x - y。“->”起分隔作用。，Java会自动翻译





添加外部jar包

project目录下----复制jar包到libs目录下-----右击jar包点击add as library



快捷键：shift + F2 快速定位到类中出错的点

​			双击shift弹出用于快速搜索工程项目类的搜索栏





##### java框架

Java框架就是一些类和接口的集合，通过这些类和接口协调来完成一系列的程序实现。框架又叫做开发中的半成品，它不能提供整个WEB应用程序的所有东西，但是有了框架，我们就可以集中精力进行业务逻辑的开发而不用去关心它的技术实现以及一些辅助的业务逻辑。说白了Java框架就是封装好方便程序员操作的类，使项目的开发更简单，维护起来也更容易。



##### error:

创建一个类时，需要指明它的构造方法，不指明系统默认

实例化一个类时需要知名它的对象，直接A a;并不能使用a的方法，会报空指针错误；


