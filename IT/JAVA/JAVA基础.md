#### Java基础知识：

1. Java虚拟机，运行Java程序的抽象计算机，是Java语言的运行环境

   

2. Java文件本质上是文本文件，后缀名为.java 的文件可以直接使用Java虚拟机jvm直接进行编译和运行

   

3. 所有Java程序的入口是main函数

   

4. Java严格区分大小写

   十进制不能以0开头

   八进制必须以0开头

   十六进制必须以0X开头

   

5. 标识符第一个字不能是数字

   

6. 常量声明需要用到关键字final，且名称通常使用大写来进行特别标记

   当final变量属于类成员变量时，必须在定义时给定初值，否则将产生编译错误

   

7. static：方便在没有创建对象实例的情况下进行调用

   1. static可以用来描述Java类中的类成员和方法，可以达到不用引用这个类的特定实例而能直接被访问。

   2. 例：main方法函数，在程序开始执行前调用main，因此用static描述

   3. 静态方法可以被直接调用，静态变量可以被直接访问，但是实例的变量和方法不能被直接访问，也不能用this关键字，因为静态方法不属于任何一个实例

   4. static可用于修饰字段、方法、属性、运算符、事件、和构造函数

   5. 类中标注了静态函数与变量能在类外面直接引用，如 

      ```
      int a = People.getAge(18);//访问静态方法
      
      People zhangsan = new People();
      int a = zhangsan.getAge(18);//使用类的实例来访问非静态方法
      ```

      

   

8. **public static void main(String [] args){}**

   解释：

   1. Java程序主要通过Java虚拟机调用，属于外部调用，需要使用public修饰程序入口main函数

   2. 没有static的变量或函数，如果想被调用的话，是要先新建一个对象才可以。而main函数作为程序的入口，需要在其它函数实例化之前就启动，这也就是为什么要加一个static。main函数好比一个门，要探索其它函数要先从门进入程序。static提供了这样一个特性，无需建立对象，就可以启动。

   3. void原因：如果main方法中出现返回值时JVM无法进行上抛

   4. String[] args是数组名字，不是固定，他声明了一个可以从控制台接受的数据类型为string数组

   5. 这个方法接受的参数数量不是固定，因此是数组形式

   6. 因此，main方法中除了args以外其他都是必须固定的格式

      

9. static静态变量，可与全局变量一拼，有利于程序的模块化，静态全局变量仅仅对当前文件可见，其他文件不可访问，在定义不需要与其他文件共享的全局变量时，加上static关键字能够有效地降低程序之间的耦合，避免不同文件同名变量之间的冲突

   静态函数只能在声明它的文件中可见，其他文件

   

10. 堆---一颗完全二叉树

    

11. 堆排序

    

12. 成员变量和静态变量的区别：

    1、生命周期的不同：

    成员变量随着对象的创建而存在随着对象的回收而释放。

    静态变量随着类的加载而存在随着类的消失而消失。

    2、调用方式不同：

    成员变量只能被对象调用。

    静态变量可以被对象调用，也可以用类名调用。（推荐用类名调用）

    3、别名不同：

    成员变量也称为实例变量。

    静态变量称为类变量。

    4、数据存储位置不同：

    成员变量数据存储在堆内存的对象中，所以也叫对象的特有数据。

    静态变量数据存储在方法区（共享数据区）的静态区，所以也叫对象的共享数据。

    （3）静态使用时需要注意的事项：

    1、静态方法只能访问静态成员。（非静态既可以访问静态，又可以访问非静态）

    2、静态方法中不可以使用this或者super关键字。

    3、主函数是静态的

    

13. java堆栈

    堆

    1. 堆中存放new的对象和数组

    2. 可以被被所有线程共享，不存放别的对象引用

       ​	Java虚拟机的基本架构采用栈来设计。当一个程序需要运行的时候，由于要预先内存空间和运行的生命周期，所以需要进行指针的变动，来进行内存大小的分配。是的，由于这个操作会对程序的执行带来一定的不方便，所以一般栈被用来存放一些基本的变量类型或者引用对象的地址，而对于存储数据量较为庞大的java对象责备存储在了堆里面了。

    栈

    1. 存放基本变量类型

    2. 引用对象的变量

       

14. 计算机处理数据基本类型是--bit（比特），就是位，一位二进制数，1或者0；

    byte是计算机文件大小的基本计算单位，一个字节是八位

    

    正数用0表示，负数用1表示

    负数计算方式：原码->反码->补码
    　　例如：十进制-8
    　　原码（负数符号位为１）：10001000；
    　　反码（符号位不变，数值位分别“按位取反”）：11110111；
    　　补码（反码的末位加1）：11111000。
    　　因此-8在8位机中用11111000表示

    

    Java

    左移把计算机中存储的二进制数据向左移动指定位数，右边空置补0；

    右移：高置位是0，右移空位补0；若高位为1，右移空位补1；

    

15. //--单行注释

    /*

    */ ---多行注释

    /**

    *

    */--文档注释，这个内容在类、成员变量、成员方法等的声明之前时，能被javadoc文档工具读取并作为javadoc文档内容，

    

16. Java基本数据类型中没有String类型

    

17. 在Java类中编写main函数使用此类中的成员变量时，这个成员变量的修饰关键字必须为static原因：

    类的加载顺序和类中代码执行顺序是：父类静态变量--父类静态块--子类静态变量--子类静态块--父类变量--父类普通块--父类构造函数（子类实例化时优先调用父类构造函数）--子类变量--子类普通块--子类构造函数

    

18. for循环，for（1；2；3）{}顺序是：1--2--循环体--3--2（判断）--循环体--3--.....

    无限循环写法：

    ```
    for (; ;)
    {
    ....
    }
    ```

    跳出无限循环需要借助break语句

    

    foreach语句是for语句的简化版本，不能取代for语句，但是任何foreach都能被写成for语句，适用于遍历数组使用

    格式：

    ```
    for(x:obj)
    {
    引用了x的Java语句；
    }
    ```

    例子：

    ```
    int arr[] = {1,3,5,2};
    for(x:arr){
    System.out.println(x);
    }
    ```

    

19. break语句只会跳出一层循环；内层循环使用break控制；

    外层循环跳出使用带标签的break

    ```
    标签名：循环体{
    	break 标签名；
    }
    ```

    

20. Java基本数据类型

    1. byte  一个字节8位  字节型
    2. short 两个字节16位   短整型
    3. int    四个字节32位  整型
    4. long   8个字节64位   长整型
    5. float   四个字节32位  浮点型单精度
    6. double   8个自己64位   浮点型双精度
    7. char    2字节16位   字符型
    8. boolean

    

21. 在Java中String借助于对象来进行管理

    String类的构造方法：

    ```
    1.String (char a[])
    例如：
    char a[] = {'a','d','f'};
    String name = new String(a);
    等价于
    String name = new Strng("asbd");
    
    2.String(char a[],int offset,int length)指的是从字符串数组中截取一部分字符，从offset开始，截取length长度
    例如：
    char a[] = {'a','s','d','f','s','g','f','c','z'};
    String name = new String(a,2,3);
    
    3.String (char[] value)标识使用了这个字符数组的所有数组元素连接在一起变成的字符串
    例如：
    char a[] = {'a','s','d','f','s','g','f','c','z'};
    String ss = new String(a)
    
    4.直接赋值
    例如：
    String ss = "nihao"
    
    ```

22. java中比较运算符“==”比较的是两个字符串的地址是否相同

    

23. 正则表达式

    其实就是用来匹配合适格式的一串字符，正则表达式自定义来创建目标字符串的格式，比如设定邮箱地址

    具体正则表达符号需要查询Java正则表达式元字符和限定修饰符

    

24. Java中格式化输出，无论是日期、时间还是数据类型我们都可以格式化

    对于字符串我的格式化使用str.format(format,object)来进行格式化，其中format可以是时间的格式化，如按照四位年份输出当前年份

    常规类型的格式化，使用“%b"、"%d"、"c"等常规转化符，来将数据转换为制定格式的类型。就像C语言中输出整除，在print后面加上“%d"

    

25. 字符串构造方法，一般适用于频繁添加字符串操作

    

26. String重要方法

    1. String str = new String(char a[])
    2. String str = new String(char a[], int offset, int length)
    3. String str = new String(char a[] value)
    4. 连接：+
    5. str.length()
    6. indexOf(string s)
    7. lastIndexOf(String s)
    8. charAt(int index)
    9. substring(int beginIndec)获取指定索引位置起到结尾的子串
    10. substring(int beginIdex,int endIndex)
    11. trim()取出空格
    12. str.replace(char oldChar,char newChar)
    13. startWith(String prefix)返回布尔类型，是否是已指定字符串开始
    14. endWith(String suffix)
    15. equal()
    16. equalIgnoreCase(String others)忽略大小写
    17. str.compareTo(String others)逐个字符比较，在前则返回1，逐个相加，返回值整数
    18. toLowerCase()
    19. toUperCase()
    20. str.split(String sign)分割
    21. str.split(String sign, int limit)分割,限定拆分次数
    22. str.format(string format, object)
    23. StringBuilder
    24. builder.append(content)
    25. builder.insert()
    26. builder.delete

    

    

    

27. 数组

    1. 声明一维数组：

       int a[];

       int[] a;

    2. 数组声明之后不能直接访问，因为还未分配内存，数组分配内存空间时必须指明数组的长度。

       分配内存空间语法格式：数组名 = new 数组元素类型[元素个数]

       a = new int [4]

       数组元素分配内存时，整形数组的各个元素初始值都为0；

    3. 声明的同时分配内存

       数组元素类型 数组名 = new 数组元素类型[元素个数]

       int a = new int [4]

    4. 初始化数组

       int a[] = new int[]{1,3,4,45};

       int a[] = {12,1,32,3}

    5. 二维数组的初始化

       数组类型 数组名[] []

       数组类型[] [] 数组名

       int aa[] [];

       int[] [] aa;

       分配内存：
       	aa  = new int [32] [3]

       ​	aa = new int [2] []; aa[0] = new int[2];aa[1] = new int[3]

       初始化：

       二维数组的每个列的长度可以不同可以使用分别初始化来进行初始化，例如：

       ```
       a = new int[2][];
       a[0] = new int[3];
       a[1] = new int[2];
       ```

       同时二维数组的可以分别查询每一维的长度，例如

       a.length返回第一维的长度；

       a[2].length返回的是第三维的长度；

    6. Array类中的方法对数组进行操作

       array.fill(数组a, int， int， value)----填充数值

       arrays.sort(数组a)----排序

       arrays.copyOf(数组a , 长度int )----复制

       arrays.copyOfRanger(数组a , 起始长度int，终点下标 )

       arrays.binarySearch(数组a,起始int , 终点int 对象key)---数组查询，返回对象的下标

       

28. 面向对象程序设计具有的特点：封装性、继承性、多态性

    封装：将对象的属性和行为封装起来。载体是类

    继承：利用特定对象之间的共有属性，父类与子类之间的存在一个层次关系

    多态：父类对象应用于子类的特征就是多态。子类使用父类的方法，我们可以统一在父类中直接修改方法，不用一一修改子类的方法，提高效率。设计知识--**抽象类、接口**

    

29. 任何方法，在执行至return关键字后立即终止，不再继续执行下去。

    

30. ###### 类成员包括成员变量和成员方法。

    

31. ##### 权限修饰符

    private、public、protect

    1. 如果类成员被private修饰，则该成员只能在本类中被使用，在子类中不可见，对其他包的类也是不可见。
    2. public描述类成员时，除了在本类中可见，在子类与其他包中也可见
    3. protect只能在本类与子类中可见，在其他包中不可见
    4. 若是不写上述关键字，则类成员默认与包的存取范围保持一致，即只有这个包中的类可以调用类成员
    5. 类的权限设定会 约束类成员的权限，就是说要是类的修饰是private，而类成员是public时，那么需要以类的修饰为准

    

32. 局部变量：在成员方法内定义的变量成为局部变量，规定：局部变量在 方法被执行时创建，在方法执行结束时被销毁，且局部变量在使用时必须进行赋值操作或被初始化

    

33. this关键字：this关键字用来隐式地调用对象的成员变量与方法，还可以作为方法的返回值

    

34. 类的构造方法：构造方法与类同名，对象的创建就是通过构造方法完成。

    构造方法没有返回值：

    构造方法名称与类名相同

    构造方法可以对成员变量赋值

    如果类中没有明确定义构造方法，编译器会自动创建一个不带参数的默认构造方法

    

35. 静态成员：静态变量、静态常量、静态方法

    静态成员属于类所有，可以在本类或其他类中进行调用

    解决两个类使用同一个变量问题，否则需要在两个类中分别创建这个常量，造成内存浪费。

    静态成员可以使用“对象.静态成员”进行调用，与费静态成员的调用一致。

    静态成员同样遵循着public、private、protect修饰符的约束。

    ##### Java规定：

    1. 静态方法中不能使用this关键字

    2. 静态方法中不能直接调用非静态方法

    3. 不能讲方法体内的局部变量声明为static

       若是不得不使用，可以现在执行前使用static开辟一个静态区域，如

       ```
       public class people{
       	static{
       		//some
       	}
       }
       ```

36. #### 对象：

    是类抽象出来的一个特例，通过new来创建。

    实际上new操作符是通过调动构造方法来创建对象

    类的对象被创建出来时，就是对一个对象的引用，这个引用在内存中为对象分配了存储空间。

    每个对象都是互相独立的，在内存中占据独立的内存地址，都有各自的生命周期。当每个对象的生命周期结束时，对象就变成了垃圾，由Java虚拟机自带的垃圾回收机制处理，不能再次被使用了

37. Book book = new Book()

    类名 对象引用名

    引用其实就是一个对象的内存地址，并不是存放一个对象，严格地说，引用和对象是不同的，但是可以忽略个中区别，可以简单地直接说book是Book类的一个对象，而事实上book只是包含Book对象的一个引用

    a = b;//b的引用赋给了a 

    

38. 对象之间的比较

    两种方式----“==”、“equal（）“

    区别："=="比较的是两个对象引用的地址是否相等

    “equal”比较的是两个对象引用的内容是否相等

    

39. 对象的销毁：

    生命周期的结束、内存地址被回收

    如下情况会被视为垃圾：

    1. 对象引用超过作用范围
    2. 对象被赋值为null

    垃圾的自动回收只能回收那些被new所创建的对象。

    ​	当不是通过new在内存中获取内存区域时，不能被垃圾回收机制识别，需要使用**finalize()**，这个方法是object类的方法，他被声明为protected，用户可以在自己的类中定义这个方法。

    ​	由于垃圾回收机制不受人为控制，具体时间不能 确定，因此finalize（）方法无法被执行，因此Java提供了System.gc()方法强制启动垃圾回收器。

    

40. byte 字节类型，其实就是表示整型，只是他对应字节类存储，长度也受限较一般整型取值范围较小

    

41. 包装类：将一些基本数据类型以及一些辅助方法包装在类中

    Java中数据类型分为基本数据类型和引用数据类型，基本数据类型并不具有对象特征，他们不能像对象那样拥有属性和方法，以及对象化交互。包装类的产生使得基本数据类型获取对象一样的特征

    Interger类、Long类、Short类分别是int、long、short封装的一个类

    1. Interger类的常用方法

       byteValue（）以byte类型返回Interger值

       compareTo（Interger anoterInterger)比较两个Interger数值

       equals（）；判断是否相等

       intValue（）；

    

42. Number类

    number是Interger、Byte、Double...等所有类的父类，number的子类必须提供将表示的数值转换为它们之间任一个类型的方法。如：floatValue（）方法

    

43. 数字处理类：DecimalFormat、Math类、Random类、BigInterger类、BigDecimal类

    

44. DecimalFormat用于格式化一些十进制数字，可以使用它来格式化操作

    先要创建一个DecimalFormat对象，使用它的应用pattern方法，其中有两种方式，一种在创建时设置格式化；另一种使用applyPattern方法进行设置格式

    ```
    DecimalFormat myFormat = new DecimalFormat(pattern);
    String output = myFormat.format(value);
            
    
    DecimalFormat myFormat = new DecimalFormat();
    myFormat.applyPattern(pattern);
          
    ```

    

45. 数学运算：

46. math.方法

    其中方法有：sin   cos  tan  asin  acos  atan  toRadians  toDegrees

    指数函数方法：

    exp：自然数的a次方

    log：自然对数loga

    log10():底数为10 的对数

    sqrt()：取a的平方根，其中参数不能为负数

    cbrt():取a的立方根

    pow（a, b）：取a的b次方

    

47. 取整函数

    ceil():返回大于等于参数的最小整数

    floor（）：返回小于等于参数的最大整数

    rint（）：返回最接近的整数，然后强制转换成长整型

    round():将参数加上0.5后返回与参数最近的整数

    取最值方法：

    max

    min

    abs:取参数的绝对值

    以上各方法的返回值类型根据输入参数的返回值决定，当精度不一致时，以精度高的为准

    

48. 随机数

    Math.random();产生随机数字，默认生成大于0.0小于1.0的double类型，一般都是在此基础上稍加处理即可产生任意范围的随机数	

    例如

    ```
    //获取a到b之间的随机数
    return a + Math.random() * (b - a);
    ```

49. random类

    除了math中提供的random方法，Java提供了random类，这种方式是以系统时间作为随机数生成器的种子，用来创建随机数
    Random r = new Random(随机数种子)

    random类中提供了几种产生随机数的方法：

    nextInt：返回一个随机整数

    nextInt（n）：返回一个大于等于0小于n随机整数

    nextlong():

    nextBoolean

    nextFloat

    nextDouble

    nextGaussian()随机产生一个概率密度为高斯分布的双精度值

    

50. BigInterger类、BigDecimal类针对大数字操作

    BigInterfer针对大整数的处理类，BigDecimal类时针对大小数的处理类

    1. BigInterger用来处理比Interger类型数字范围更大的数据

       构造方法是public BigInterger (String val)参数是字符串形式

    2. BigDecimal中相较于BigInterger中加入了小数的概念，

